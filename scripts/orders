#!/usr/bin/env python

from pandaemonium import PidLockFile, AlreadyLocked
from scription import Script, Command, Main, mail, REQUIRED, OPTION, MULTI
from syslog import syslog
from VSS import Date, DateTime
from VSS.path import Path
from VSS.time_machine import PropertyDict
from VSS.utils import ProgressBar, Enum, IntEnum, AutoEnum
from VSS.openerp import get_records
import openerplib
import shutil
import socket
import time

SOURCE = Path('/var/fis/')
ARCHIVE = Path('/var/openerp/archive/shipping/')
ERRORS = Path('/var/openerp/archive/shipping/error')
USER_PW_DB = Path('/etc/openerp/credentials')

execfile(USER_PW_DB)

OE = PropertyDict()

fis_module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

class OrderState(IntEnum):
    draft = 1
    scheduled = 2
    appt = 3
    ready = 4
    checked_in = 5
    complete = 6
    cancelled = 7
globals().update(OrderState.__members__)

class BadFormat(Exception):
    "order is incomplete"

class MissingPartner(Exception):
    "unable to find partner"

def archive(src_file, dest=ARCHIVE):
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    existing = dest.glob(basename+'*')
    existing.sort()
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].split('_')
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)

def get_order(order):
    g = {}
    execfile(order, g)
    if 'order' not in g:
        raise BadFormat('empty file?')
    return PropertyDict(g['order'])

def update_order(values):
    if not values.local_source_document:
        raise BadFormat('missing local source document')
    context = PropertyDict()
    local_contacts = values.pop('local_contact', None)
    if local_contacts is not None:
        if 'sysadmin' in local_contacts:
            local_contacts.remove('sysadmin')
        records = OE.res_users.search_read(fields=['id'], domain=[('login','in',local_contacts)])
        values.local_contact_ids = [lc['id'] for lc in records]
    partner_xmlid = values.pop('partner_xmlid', None)
    if partner_xmlid is not None:
        records = OE.res_partner.search_read(fields=['id', 'module', 'xml_id'], domain=[('module','=',fis_module[values.direction]),('xml_id','=',partner_xmlid)])
        if not records:
            raise MissingPartner('unable to find partner %r' % partner_xmlid)
        partner_id = records[0]['id']
        values.partner_id = context.default_partner_id =  partner_id
    carrier_xmlid = values.pop('carrier_xmlid', None)
    if carrier_xmlid not in (None, ):
        records = OE.res_partner.search_read(fields=['id'], domain=[('module','=',fis_module['carrier']),('xml_id','=',carrier_xmlid)])
        if not records:
            records = OE.res_partner.search_read(fields=['id'], domain=[('module','=',fis_module['carrier']),('xml_id','=','99')])
            if not records:
                raise MissingPartner('unable to find carrier %r' % carrier_xmlid)
        carrier_id = records[0]['id']
        values.carrier_id = carrier_id
    direction = values.get('direction')
    if direction == 'incoming':
        values.job_title = values.preposition = values.partner_source_document_type = 'purchasing'
    elif direction == 'outgoing':
        values.job_title = values.preposition = values.partner_source_document_type = 'sales'
    if 'cartons' in values:
        values.cartons = int(values.cartons) or False
    if 'pallets' in values:
        values.pallets = int(values.pallets) or False
    if 'weight' in values:
        values.weight = float(values.weight) or False
    orders = OE.fnx_shipping.search_read(fields=['id', 'appt_confirmed', 'state'], domain=[('local_source_document','=',values.local_source_document)])
    order = None
    for order in orders:
        break
    if not order and not direction:
        raise BadFormat('cannot create new document %r without a direction' % values.local_source_document)
    elif not order:
        values.state = 'draft'
    elif 'pallets' in values and values.pallets:
        if order['state'] in ('checked_in', 'complete', 'cancelled'):
            pass
        elif order['state'] == 'scheduled':
            values.state = 'ready'
        else:
            values.state = 'appt'
    login = values.pop('user', None)
    if login:
        records = OE.res_users.search_read(fields=['id'], domain=[('login','=',login)])
        values.login_id = records[0]['id']
    if not order:
        try:
            OE.fnx_shipping.create(dict(values), context=dict(context))
        except Exception, exc:
            print(exc)
            raise
    else:
        try:
            OE.fnx_shipping.write([order['id']], dict(values))
        except Exception, exc:
            print(exc.faultCode)
            raise

def get_files(source=SOURCE):
    files = [source/f for f in source.listdir() if f != 'order_template']
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def connect_oe(hostname, database, user, password):
    OE.conn = conn = openerplib.get_connection(hostname=hostname, database=database, login=user, password=password)
    OE.res_partner = conn.get_model('res.partner')
    OE.res_users = conn.get_model('res.users')
    OE.fnx_shipping = conn.get_model('fnx.sr.shipping')


@Command(
        remove=('remove identical duplicates', 'flag', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def find_duplicates(hostname='localhost', db=DB, login=USER, password=None, remove=False):
    """Look for duplicate orders; print any found"""
    if password is None:
        password = PW
    connect_oe(hostname, db, login, password)
    records = OE.fnx_shipping.search_read(fields=['id', 'local_source_document'], )
    order_numbers = set()
    duplicates = list()
    removed = list()
    removed_ids = list()
    pb = ProgressBar(len(records), message="processing %d records" % len(records))
    for sr in records:
        pb.tick()
        sr = PropertyDict(sr)
        if sr.local_source_document in order_numbers:
            duplicates.append(sr.local_source_document)
        else:
            order_numbers.add(sr.local_source_document)
    if not duplicates:
        print '\nNo duplicates found.\n'
    else:
        print '\n%d duplicates found in %d orders:\n' % (len(duplicates), len(records))
        if remove:
            pb = ProgressBar(len(duplicates), message='checking %d records' % len(duplicates))
            for dup in duplicates:
                pb.tick()
                dups = OE.fnx_shipping.search_read(domain=[('local_source_document','=',dup)])
                if len(dups) > 2:
                    continue
                d0 = PropertyDict(dups[0])
                d1 = PropertyDict(dups[1])
                d0_state = OrderState[d0.state]
                d1_state = OrderState[d1.state]
                d0_msgs = len(d0.message_ids)
                d1_msgs = len(d1.message_ids)
                if ( ( d0_state != complete and d1_state == complete)
                  or ( d0_state == complete and d1_state != complete)
                  ):
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                elif d0_state > d1_state:
                    removed.append(d1.local_source_document)
                    removed_ids.append(d1.id)
                elif d1_state > d0_state:
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                elif d0_msgs > d1_msgs:
                    removed.append(d1.local_source_document)
                    removed_ids.append(d1.id)
                elif d1_msgs > d0_msgs:
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                else:
                    d0_id = d0.pop('id')
                    d1_id = d1.pop('id')
                    d0.pop('message_ids')
                    d1.pop('message_ids')
                    if d0 == d1:
                        removed.append(d1.local_source_document)
                        removed_ids.append(d1_id)
            if removed:
                duplicates = [lsd for lsd in duplicates if lsd not in removed]
                OE.fnx_shipping.unlink(removed_ids)
                print '\n'
            for r in removed:
                print '\t', r
            print '\n\nremaining...'
        for dup in sorted(duplicates):
            print '\t', dup


@Command(
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def fix_carriers(hostname='localhost', db=DB, login=USER, password=PW):
    """
    compare OE values for carrier with values in files -- if OE value is '99'
    and file value is not, set to file value
    """
    if password is None:
        password = PW
    connect_oe(hostname, db, login, password)
    records = OE.res_partner.search_read(fields=['id'], domain=[('module','=',fis_module['carrier']),('xml_id','=','99')])
    unknown_id = records[0]['id']
    records = OE.res_partner.search_read(fields=['id','xml_id'], domain=[('module','=',fis_module['carrier'])])
    shippers = {}
    for rec in records:
        shippers[rec['xml_id']] = rec['id']
    shipping_records = OE.fnx_shipping.search_read(
            fields=['id','carrier_id','local_source_document'],
            domain=['|',('carrier_id.id','=',unknown_id),('carrier_id','=',False)])
    pb = ProgressBar(len(shipping_records), message="processing %d records" % len(shipping_records))
    for sr in shipping_records:
        pb.tick()
        sr = PropertyDict(sr)
        source_files = sorted((ARCHIVE / sr.local_source_document + '*').glob())
        order = PropertyDict()
        for sf in source_files:
            settings = get_order(sf)
            order.update(settings)
        carrier_xmlid = order.get('carrier_xmlid')
        if carrier_xmlid in shippers:
            carrier_id = shippers[carrier_xmlid]
            values = {'carrier_id':carrier_id}
            OE.fnx_shipping.write([sr.id], values)


@Command(
        values=('settings to use', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def manual_update(hostname='localhost', db=DB, login=USER, password=None, **values):
    if password is None:
        password = PW
    connect_oe(hostname, db, login, password)
    update_order(PropertyDict(values))


@Command(
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def missing_check(hostname='localhost', db=DB, login=USER, password=PW):
    if password is None:
        password = PW
    connect_oe(hostname, db, login, password)
    orders = dict(
            (item.local_source_document, item)
            for item in get_records(OE.fnx_shipping, fields=['id', 'local_source_document', 'partner_id'])
            )
    processed = [name.split('_')[0] for name in ARCHIVE.listdir()]
    for order in processed:
        if order not in orders:
            print order,
    print


@Command(
        date=('start date for missing orders', REQUIRED, 'd', Date),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def missing_reprocess(date, hostname='localhost', db=DB, login=USER, password=PW):
    if password is None:
        password = PW
    connect_oe(hostname, db, login, password)
    print 'gathering orders from OpenERP...',
    orders = dict(
            (item.local_source_document, item)
            for item in get_records(OE.fnx_shipping, fields=['id', 'local_source_document', 'partner_id'])
            )
    print '(%d found)' % len(orders), orders.keys()[:10]
    print 'gathering all orders from %s till today...' % date,
    processed_ids = dict(
            (name.filename.split('_')[0], name)
            for name in (ARCHIVE/'*').glob()
            if Date.fromtimestamp(name.stat().st_ctime) >= date and not name.endswith('/error')
            )
    print '(%d found)' % len(processed_ids), processed_ids.keys()[:10]
    lock = PidLockFile('/var/run/fnxsr-order_update.pid', time_out=300)
    lock.seal()
    i = 0
    for order_id, order_file in sorted(processed_ids.items()):
        if order_id not in orders:
            print 're-adding order', order_id
            i += 1
            order = get_order(order_file)
            update_order(order)
            order_file_timestamp = order_file.stat().st_ctime
            error_updates = sorted([
                    name
                    for name in (ERRORS/order_id+'*').glob()
                    if name.stat().st_ctime > order_file_timestamp
                    ])
            for err_update in error_updates:
                print 're-adding error', err_update
                order = get_order(err_update)
                update_order(order)
            print
            if i % 10:
                lock.release()
                print 'letting system get a word in edgewise...'
                time.sleep(90)
                lock.seal()
                print 'okay, processing some more'
    lock.release()


@Command(
        file_to_process=('order to add/update in system', OPTION, ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def update(file_to_process, hostname='localhost', db=DB, login=USER, password=PW):
    if password is None:
        password = PW
    if file_to_process:
        files = [file_to_process]
        lock = None
    else:
        try:
            lock = PidLockFile('/var/run/fnxsr-order_update.pid', time_out=30)
            lock.seal()
        except AlreadyLocked:
            raise SystemExit
        files = get_files()
    for _ in range(30):
        # keep trying to get a connection for 30 minutes
        try:
            connect_oe(hostname, db, login, password)
            break
        except socket.error:
            time.sleep(60)
    try:
        retry = []
        failed = []
        for group in ((files, failed), ):
            time.sleep(5)
            trying, failing = group
            for file in trying:
                try:
                    order = get_order(file)
                    update_order(order)
                    dest = ARCHIVE
                except (BadFormat, MissingPartner, ), exc:
                    failing.append('%s: %s' % (file, exc.message or exc.args))
                    dest = ERRORS
                except (IOError, ), exc:
                    failing.append('%s: %s' % (file, exc.message or exc.args))
                    dest = None
                    continue
                if dest:
                    archive(file, dest)
        if failed:
            raise Exception("Unable to process orders:\n\t%s" % '\n\t'.join(failed))
    finally:
        if lock:
            lock.release()

@Command(
        file_to_process=('order to add/update in system', MULTI, 'f', Path, ),
        date=('reprocess all files from <date>', MULTI, 'd', Date, ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def reprocess(file_to_process, date, hostname='localhost', db=DB, login=USER, password=PW):
    if password is None:
        password = PW
    if file_to_process is None and date is None:
        raise Exception('either file(s) or date(s) must be specified')
    if file_to_process:
        files = [ARCHIVE/f for f in file_to_process]
    else:
        files = [
                f
                for f in get_files(ARCHIVE)
                if DateTime.fromtimestamp(f.stat().st_mtime).date() in date
                ]
    failed = []
    for file in files:
        try:
            order = get_order(file)
            update_order(order)
        except Exception, exc:
            failed.append((str(exc), file))
    if failed:
        raise Exception("Unable to re-process orders:\n\t%s" % '\n\t'.join(failed))

Main()
