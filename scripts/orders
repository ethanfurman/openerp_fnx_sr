#!/usr/local/sbin/suid-python --virtualenv

# setup
from __future__ import print_function

from collections import defaultdict
from dbf import Date, DateTime, Time
from aenum import Enum, IntEnum
from pandaemonium import PidLockFile, AlreadyLocked
from scandir import scandir
from scription import *
from VSS.BBxXlate.fisData import fisData
from VSS.utils import fix_date, date
from antipathy import Path
from VSS.time_machine import PropertyDict
from VSS.utils import ProgressBar
from logging import INFO, getLogger, Formatter, handlers
from openerplib import get_connection, get_records, Many2One, DEFAULT_SERVER_DATE_FORMAT
from openerplib.dates import LOCAL_TIME
from updates.fis_schema import F36, F219
import os
import shutil
import socket
import time
import xmlrpclib

virtualenv = os.environ['VIRTUAL_ENV']
logger = getLogger()
logger.setLevel(INFO)
_handler = handlers.TimedRotatingFileHandler(
        '%s/var/log/fnx_sr.log' % virtualenv,
        when='midnight',
        backupCount=30,
        )
_formatter = Formatter('%(asctime)s %(funcName)-25s %(message)s')
_handler.setFormatter(_formatter)
logger.addHandler(_handler)
del _handler, _formatter
SOURCE = Path('%s/var/fis/' % virtualenv)

ARCHIVE = Path('%s/var/openerp/archive/shipping/' % virtualenv)
ERRORS = Path('%s/var/openerp/archive/shipping/error' % virtualenv)
CONFIG = Path('%s/config/fnx.ini' % virtualenv)

try:
    settings = OrmFile(CONFIG, section='openerp')
except Exception:
    echo('WARNING: unable to process configfile; all parameters must be specified')
    HOST = ''
    USER = ''
    DB = ''
    PW = ''
else:
    HOST = settings.host
    USER = settings.user
    DB = settings.db
    PW = settings.pw

# set later
draft = scheduled = appt = ready = checked_in = complete = cancelled = None

# API
@Script(
        host=('host where OpenERP instance is running', OPTION),
        db=('database to use', OPTION),
        user=('login name to use', OPTION),
        pw=('password for login name', OPTION),
        )
def main(host, db, user, pw):
    if host:
        module.HOST = host
    if db:
        module.DB = db
    if user:
        module.USER = user
    if pw:
        module.PW = pw
    for req in ('HOST', 'USER', 'DB', 'PW'):
        if not module[req]:
            raise SystemExit('%r required; use --help for more info' % req)
    global logger
    logger = getLogger('orders')


@Command(
        order=('specific order to check', OPTION),
        )
def order_check(order):
    orders = defaultdict(list)
    if order != '*':
        order += '_*'
    for file_name in ARCHIVE.glob(order):
        if '_' not in file_name:
            continue
        base, seq = file_name.filename.split('_')
        orders[int(base)].append(file_name)
    for order_no in reversed(sorted(orders.keys())):
        files = orders[order_no]
        print('checking', order_no)
        print('  with:\n     %s' % '\n     '.join(sorted(files)), verbose=2)
        complete_order = load_order(*files)
        if order != '*':
            print_table(*complete_order)
            return
        pallets_cleared = False
        for values in reversed(complete_order):
            if values.get('state') == 'complete':
                break
            elif values.get('pallets') == 0:
                pallets_cleared = True
            elif values.get('pallets'):
                if not pallets_cleared:
                    break
                # at this point we know that pallets were reset back to zero,
                # so we can check this order in OpenERP to see if the reset
                # failed as it should
                #
                # print out the progress of the order so we can see how it
                # evolved
                print_table(*complete_order)
                if get_response('Continue?'):
                    continue
                else:
                    return


@Command(
        remove=('remove identical duplicates', 'flag', ),
        )
def find_duplicates(remove=False):
    """Look for duplicate orders; print any found"""
    logger.info('find_duplicates(remove=%r)', remove)
    connect_oe(HOST, DB, USER, PW)
    records = OE.fnx_shipping.search_read(fields=['id', 'local_source_document'], )
    order_numbers = set()
    duplicates = list()
    removed = list()
    removed_ids = list()
    pb = ProgressBar(len(records), message="processing %d records" % len(records))
    for sr in records:
        pb.tick()
        sr = PropertyDict(sr)
        if sr.local_source_document in order_numbers:
            duplicates.append(sr.local_source_document)
        else:
            order_numbers.add(sr.local_source_document)
    if not duplicates:
        print('\nNo duplicates found.\n', verbose=0)
    else:
        print('\n%d duplicates found in %d orders:\n' % (len(duplicates), len(records)), verbose=0)
        if remove:
            pb = ProgressBar(len(duplicates), message='checking %d records' % len(duplicates))
            for dup in duplicates:
                pb.tick()
                dups = OE.fnx_shipping.search_read(domain=[('local_source_document','=',dup)])
                if len(dups) > 2:
                    continue
                d0 = PropertyDict(dups[0])
                d1 = PropertyDict(dups[1])
                d0_state = OrderState[d0.state]
                d1_state = OrderState[d1.state]
                d0_msgs = len(d0.message_ids)
                d1_msgs = len(d1.message_ids)
                if ( ( d0_state != complete and d1_state == complete)
                  or ( d0_state == complete and d1_state != complete)
                  ):
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                elif d0_state > d1_state:
                    removed.append(d1.local_source_document)
                    removed_ids.append(d1.id)
                elif d1_state > d0_state:
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                elif d0_msgs > d1_msgs:
                    removed.append(d1.local_source_document)
                    removed_ids.append(d1.id)
                elif d1_msgs > d0_msgs:
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                else:
                    d0.pop('id')
                    d1_id = d1.pop('id')
                    d0.pop('message_ids')
                    d1.pop('message_ids')
                    if d0 == d1:
                        removed.append(d1.local_source_document)
                        removed_ids.append(d1_id)
            if removed:
                duplicates = [lsd for lsd in duplicates if lsd not in removed]
                OE.fnx_shipping.unlink(removed_ids)
                print('\n', verbose=0)
            for r in removed:
                print('\t', r, verbose=0)
            print('\n\nremaining...', verbose=0)
        for dup in sorted(duplicates):
            print('\t', dup, verbose=0)


@Command()
def fix_appts():
    "remove appointment if last set by administrator"
    logger.info('removing appointments set by administrator')
    print('connecting to %s:%s' % (HOST, DB))
    connect_oe(HOST, DB, USER, PW)
    fnx_sr_shipping = OE.conn.get_model('fnx.sr.shipping')
    updated = 0
    try:
        for ticket in ViewProgress(
                message='Checking $total records...',
                view_type='bar',
                iterable=get_records(
                    fnx_sr_shipping,
                    domain=[('appointment','!=',False),('state','!=','cancelled')],
                    fields=['id','local_source_document','message_ids','appointment_date','appointment_time'],
                    )
            ):
            for msg in get_records(
                    OE.conn, 'mail.message',
                    domain=[('id','in',ticket.message_ids)],
                    fields=['id','author_id','body'],
                ):
                if "<b>Appointment</b>" in msg.body:
                    if msg.author_id.id == 3:
                        # most recent appointment set by administrator, remove it
                        fnx_sr_shipping.write(
                                ticket.id,
                                {
                                    'ship_date': ticket.appointment_date,
                                    'appointment_date': False,
                                    'appointment_time': False,
                                    },
                                )
                        updated += 1
                    break
    finally:
        echo('\n%d records updated' % updated)

@Command()
def fix_carriers():
    """
    compare OE values for carrier with values in files -- if OE value is '99'
    and file value is not, set to file value
    """
    logger.info('fix_carriers()')
    connect_oe(HOST, DB, USER, PW)
    records = OE.res_partner.search_read(fields=['id'], domain=[('module','=',fis_module['carrier']),('xml_id','=','99')])
    unknown_id = records[0]['id']
    records = OE.res_partner.search_read(fields=['id','xml_id'], domain=[('module','=',fis_module['carrier'])])
    shippers = {}
    for rec in records:
        shippers[rec['xml_id']] = rec['id']
    shipping_records = OE.fnx_shipping.search_read(
            fields=['id','carrier_id','local_source_document'],
            domain=['|',('carrier_id.id','=',unknown_id),('carrier_id','=',False)])
    pb = ProgressBar(len(shipping_records), message="processing %d records" % len(shipping_records))
    for sr in shipping_records:
        pb.tick()
        sr = PropertyDict(sr)
        source_files = sorted((ARCHIVE / sr.local_source_document + '*').glob())
        order = PropertyDict()
        for sf in source_files:
            settings = get_order(sf)
            order.update(settings)
        carrier_xmlid = order.get('carrier_xmlid')
        if carrier_xmlid in shippers:
            carrier_id = shippers[carrier_xmlid]
            values = {'carrier_id':carrier_id}
            OE.fnx_shipping.write([sr.id], pfm(values))


@Command()
def info():
    logger.info('info()')
    print('loading OPAR', verbose=0)
    opar = fisData(54, subset='10%6s%6s')
    print('total OPAR records:', len(opar), verbose=0)
    opar_company = fisData(54, subset='%2s')
    print('OPAR possible matches:', len(opar_company.get_subset(('10',))), verbose=0)
    connect_oe(HOST, DB, USER, PW)
    print('getting partner records', verbose=0)
    partners = dict([
            (r.id, r.xml_id)
            for r in get_records(
                OE.res_partner,
                fields=['id', 'xml_id'],
                )
            ])
    print('getting orders', verbose=0)
    all_orders = get_records(
            OE.fnx_shipping,
            fields=['id', 'state', 'name', 'direction', 'ship_date', 'partner_id', 'local_source_document'],
            )
    month = defaultdict(lambda: dict(total=0, outgoing=0, incoming=0, opar=0, draft=0, ready=0, loading=0, complete=0, cancelled=0, unknown=0))
    totals = dict(total=0, outgoing=0, incoming=0, opar=0, draft=0, ready=0, loading=0, complete=0, cancelled=0, unknown=0)
    pb = ProgressBar(len(all_orders), message="tallying orders")
    for order in all_orders:
        pb.tick()
        appt = order.ship_date and order.ship_date[:7] or False
        if order.partner_id and order.partner_id.id in partners and opar.get_subset((partners[order.partner_id[0]], order.local_source_document)):
            month[appt]['opar'] += 1
            totals['opar'] += 1
        month[appt]['total'] += 1
        if order.direction:
            month[appt][order.direction] += 1
            totals[order.direction] += 1
        if order.direction == 'outgoing':
            month[appt][order.state or 'unknown'] += 1
            totals[order.state or 'unknown'] += 1
        totals[order.direction] += 1
        totals['total'] += 1
    print('        | incoming  outgoing | open a/r | draft  ready  loading  complete  cancelled  unknown | totals', verbose=0)
    print('------- + --------  -------- + -------- + -----  -----  -------  --------  ---------  ------- + ------', verbose=0)
    template = '%(month)7s | %(incoming)8s  %(outgoing)8d | %(opar)8s | %(draft)5d  %(ready)5d  %(loading)7d  %(complete)8d  %(cancelled)9d  %(unknown)7d | %(total)6d'
    for month, counts in sorted(month.items()):
        counts['month'] = month or 'missing'
        print(template % counts, verbose=0)
    print('------- + --------  -------- + -----  -----  -------  --------  --------- + ------ + ------', verbose=0)
    template = '%(month)7s | %(incoming)8s  %(outgoing)8d | %(opar)8s | %(draft)5d  %(ready)5d  %(loading)7d  %(complete)8d  %(cancelled)9d  %(unknown)7d | %(total)6d'
    totals['month'] = 'all'
    print(template % totals, verbose=0)



@Command(
        values=('settings to use', ),
        )
def manual_update(**values):
    # values that need to be converted from str:
    #    local_contact -> list
    logger.info('manual_update(values=%r)', values)
    connect_oe(HOST, DB, USER, PW)
    lc = values.pop('local_contact', None)
    if lc is not None:
        values['local_contact'] = lc.split(',')
    update_order(PropertyDict(values))


@Command()
def missing_check():
    logger.info('missing_check()')
    connect_oe(HOST, DB, USER, PW)
    orders = dict(
            (item.local_source_document, item)
            for item in get_records(OE.fnx_shipping, fields=['id', 'local_source_document', 'partner_id'])
            )
    processed = [name.split('_')[0] for name in ARCHIVE.listdir()]
    for order in processed:
        if order not in orders:
            print(order, verbose=0)
    print(verbose=0)


@Command(
        dryrun=('display affected records instead of deleting them', FLAG),
        )
def purge(dryrun):
    """
    removes completed or out-of-date orders and their interface files

    criteria:
    - shipping, complete, more than 3 months old, and not in OPAR; or
    - receiving, complete, and more than 6 months old; or
    - more than 1 year old
    """
    logger.info('purge(dryrun=%r)', dryrun)
    print('connecting to %s:%s' % (HOST, DB))
    connect_oe(HOST, DB, USER, PW)
    print('loading OPAR')
    opar = fisData(54, subset='10%6s%6s')
    print('total OPAR records:', len(opar))
    opar_company = fisData(54, subset='%2s')
    print('OPAR possible matches:', len(opar_company.get_subset(('10',))))
    fields = ['id', 'local_source_document', 'partner_id']
    print('getting candidate shipped orders')
    shipped_orders = dict([(o.local_source_document, o)
            for o in get_records(
                OE.fnx_shipping,
                domain=[('direction','=','outgoing'),('state','in',['complete','cancelled']),('appointment_date','<','Month6')],
                fields=fields,
                )])
    print('getting candidate received orders')
    received_orders = dict([(o.local_source_document, o)
            for o in get_records(
                OE.fnx_shipping,
                domain=[('direction','=','incoming'),('state','in',['complete','cancelled']),('appointment_date','<','Month6')],
                fields=fields,
                )])
    print('getting aged-out incomplete orders')
    dead_orders = dict([(o.local_source_document, o)
            for o in get_records(
                OE.fnx_shipping,
                domain=['|',('state','=',False),('state','not in',['complete','cancelled']),('appointment_date','<','Month12')],
                fields=fields,
                )])
    print('getting partner records')
    partners = dict([
            (r.id, r.xml_id)
            for r in get_records(
                OE.res_partner,
                fields=['id', 'xml_id'],
                )
            ])
    # check each shipped order to make sure it does not have an
    # open A/R invoice attached
    pb = ProgressBar(len(shipped_orders)+len(received_orders)+len(dead_orders), message="calculating dead orders")
    dead_shipped_ids = set()
    dead_received_ids = set()
    dead_ids = set()
    dead_files = set()
    all_dead_ids = set()
    errors = set()
    error_count = 0
    for id_tracker, id_source, check_inv in (
            (dead_shipped_ids, shipped_orders, True),
            (dead_received_ids, received_orders, False),
            (dead_ids, dead_orders, False),
            ):
        for local_source_document, record in id_source.items():
            pb.tick()
            try:
                partner = partners[record.partner_id[0]]
            except KeyError:
                errors.add(record.partner_id[0])
                error_count += 1
                continue
            if check_inv and opar.get_subset((partner, local_source_document)):
                # open A/R invoices exist
                continue
            id_tracker.add(record.id)
            all_dead_ids.add(record.id)
    # find dead files
    # - get all records
    # - filter to live records
    # - mark non-live files
    all_orders = get_records(OE.fnx_shipping, fields=['local_source_document'])
    live_lsds = set([o.local_source_document for o in all_orders if o.id not in all_dead_ids])
    # error directory is "live"
    live_lsds.add('error')
    # all_order_ids = set([o.id for o in all_orders])
    # all_order_lsds = set([o.local_source_document for o in all_orders])
    dead_files = []
    for folder in (ARCHIVE, ERRORS):
        for entry in scandir(folder):
            entry = Path(entry.path)
            stem = entry.filename.split('_')[0]
            days_old = (DateTime.now() - DateTime.fromtimestamp(entry.stat().st_mtime)).days
            if stem not in live_lsds and days_old > 90:
                dead_files.append(entry)
    if errors:
        error('%d records had %d supplier codes missing from OpenERP (%s)' % (error_count, len(errors), ', '.join([str(e) for e in sorted(errors)])))
    if dryrun:
        print('%d shipped candidates' % len(shipped_orders), verbose=0)
        print('%d dead shipped' % len(dead_shipped_ids), verbose=0)
        print('%d dead receivables' % len(received_orders), verbose=0)
        print('%d dead dead' % len(dead_orders), verbose=0)
        print('%d orphaned files' % len(dead_files), verbose=0)
    else:
        # delete the old stuff
        if dead_shipped_ids:
            # starting with the dead shipped
            print('removing %d shipped orders' % len(dead_shipped_ids))
            OE.fnx_shipping.unlink(list(dead_shipped_ids))
        if dead_received_ids:
            # and the old purchased orders
            print('removing %d received orders' % len(dead_received_ids))
            OE.fnx_shipping.unlink(list(dead_received_ids))
        if dead_ids:
            # and the seriously old stuff
            print('removing %d very old orders' % len(dead_ids))
            OE.fnx_shipping.unlink(list(dead_ids))
        if dead_files:
            # and then the interface files
            print('removing %d orphaned files' % len(dead_files))
            for entry in dead_files:
                entry.unlink()


@Command(
        file_to_process=('order to add/update in system', MULTI, 'f', Path, ),
        date=('reprocess all files from <date>', MULTI, 'd', Date, ),
        )
def reprocess(file_to_process, date):
    logger.info('reprocess(file_to_process=%r, date=%r', file_to_process, date)
    if not (file_to_process or date):
        raise SystemExit('either file(s) or date(s) must be specified')
    if file_to_process:
        files = [ARCHIVE/f for f in file_to_process]
    else:
        files = [
                f
                for f in get_files(ARCHIVE)
                if DateTime.fromtimestamp(f.stat().st_mtime).date() in date
                ]
    failed = []
    for file in files:
        try:
            order = get_order(file)
            update_order(order)
        except Exception, exc:
            failed.append((str(exc), file))
    if failed:
        raise Exception("Unable to re-process orders:\n\t%s" % '\n\t'.join(failed))

@Command()
def reprocess_error():
    """
    goes through the errors directory and reprocesses any orders that are
    either missing or still open
    """
    logger.info('reprocess_error()')
    connect_oe(HOST, DB, USER, PW)
    print('gathering orders from OpenERP...')
    orders = dict(
            (item.local_source_document, item)
            for item in get_records(OE.fnx_shipping, fields=['id', 'local_source_document', 'partner_id', 'state'])
            )
    candidates = ERRORS.glob('*')
    candidates.sort(key=lambda c: c.stat().st_ctime)
    for mishap in candidates:
        try:
            order = get_order(mishap)
        except BadFormat:
            continue
        oe_order = orders.get(order.local_source_document)
        if order.local_source_document[0].isalpha():
            # weird stuff, skip it
            continue
        if oe_order is not None and oe_order.state in ('complete', 'cancelled'):
            # it's closed, don't sweat it
            continue
        print('updating %s' % order.local_source_document)
        try:
            update_order(order)
        except MissingPartner:
            continue


@Command(
        date=('start date for missing orders', REQUIRED, 'd', Date),
        )
def reprocess_missing(date):
    logger.info('reprocess_missing(date=%r)', date)
    connect_oe(HOST, DB, USER, PW)
    print('gathering orders from OpenERP...',)
    orders = dict(
            (item.local_source_document, item)
            for item in get_records(OE.fnx_shipping, fields=['id', 'local_source_document', 'partner_id'])
            )
    print('(%d found)' % len(orders), orders.keys()[:10])
    print('gathering all orders from %s till today...' % date,)
    processed_ids = dict(
            (name.filename.split('_')[0], name)
            for name in (ARCHIVE/'*').glob()
            if Date.fromtimestamp(name.stat().st_ctime) >= date and not name.endswith('/error')
            )
    print('(%d found)' % len(processed_ids), processed_ids.keys()[:10])
    lock = PidLockFile('/var/run/fnxsr-order_update.pid', timeout=300)
    lock.seal()
    i = 0
    for order_id, order_file in sorted(processed_ids.items()):
        if order_id not in orders:
            print('re-adding order', order_id)
            i += 1
            order = get_order(order_file)
            update_order(order)
            order_file_timestamp = order_file.stat().st_ctime
            error_updates = sorted([
                    name
                    for name in (ERRORS/order_id+'*').glob()
                    if name.stat().st_ctime > order_file_timestamp
                    ])
            for err_update in error_updates:
                print('re-adding error', err_update)
                order = get_order(err_update)
                update_order(order)
            print()
            if i % 10:
                lock.release()
                print('letting system get a word in edgewise...')
                time.sleep(90)
                lock.seal()
                print('okay, processing some more')
    lock.release()


@Command(
        what=Spec('what to synchronize', choices=['erp', 'fis']),
        show_missing=Spec('show missing orders when syncing status', FLAG, 'm'),
        reopen=Spec('reopen closed orders', FLAG),
        orders=Spec('only affect these orders', OPTION),
        )
def sync(what, show_missing, reopen, *orders):
    '''
    synchronizes data either within OpenERP or with FIS
    '''
    logger.info('sync(what=%r, show_missing=%r, reopen=%r, orders=%r)', what, show_missing, reopen, orders)
    if what == 'erp':
        sync_openerp(orders)
    elif what == 'fis':
        sync_fis(show_missing, reopen, orders)


@Command(
        file=('order to add/update in system', OPTION, 'f', Path),
        directory=('directory of orders to add/update in system', OPTION, 'd', Path),
        )
def update(file, directory=SOURCE):
    """
    Add files with the structure of

        order={
          'ship_date': '20140107',
          'carrier_xmlid': '99',
          'cartons': '9',
          'direction': 'outgoing',
          'local_contact': ['sysadmin', 'rgiannini', 'ethan'],
          'local_source_document': '999999',
          'pallets': 0,
          'partner_source_document': 'PO TEST',
          'partner_xmlid': 'AWGRO',
          'weight': '139',
          }

    to OpenERP.FnxSR, then update that entry with information from
    FIS RDER.
    """
    logger.info('update(file=%r, directory=%r', file, directory)
    global fis_orders, fis_purchases, oe_carriers
    if file:
        files = [file]
        lock = None
    else:
        if not directory.exists():
            abort('directory %s does not exist' % directory)
        try:
            lock = PidLockFile('/var/run/fnxsr-order_update.pid', timeout=30)
            lock.seal()
        except AlreadyLocked:
            return
        files = get_files(directory)
        if not files:
            lock.release()
            return
    try:
        print('connecting to OpenERP')
        connect_oe(HOST, DB, USER, PW)
    except socket.error:
        if lock:
            lock.release()
        raise SystemExit('unable to connect to OpenERP server')
    print('gathering carriers from OpenERP')
    oe_carriers = dict([
        (r['xml_id'], r['id'])
        for r in get_records(
            OE.conn, 'res.partner',
            fields=['id','xml_id'],
            domain=[('module','=',fis_module['carrier'])],
            )
        ])
    print('gathering orders from FIS')
    fis_orders = fisData(36, subset='10%6s')
    print('gathering purchases from FIS')
    fis_purchases = fisData(219, subset='10%5s')
    try:
        failures = False
        bad_orders = []
        for file in files:
            try:
                order = get_order(file)
                logger.info(
                        '%s: %s',
                        file.name,
                        ', '.join('%s=%r' % (k, v) for k, v in sorted(order.items()))
                        )
                if order.local_source_document[0].isalpha():
                    dest = ERRORS
                else:
                    update_order(order)
                    dest = ARCHIVE
            except MissingPartner as exc:
                echo('%s: %s (skipping)' % (file.filename, exc.message or exc.args), border='lined')
                dest = None
            except (BadFormat, CancelledOrder, MissingFIS) as exc:
                error('%s: %s' % (file, exc.message or exc.args))
                with open(file) as f:
                    data = '================\n%s\n----------------\n' % file
                    data += f.read() + '\n'
                    bad_orders.append(data)
                # failing.append('%s: %s' % (file, exc.message or exc.args))
                dest = ERRORS
                failures = True
            except (Exception, ), exc:
                logger.execption()
                error('%s: %s' % (file, exc.message or exc.args))
                # failing.append('%s: %s' % (file, exc.message or exc.args))
                dest = None
                failures = True
                continue
            if dest:
                archive(file, dest)
        if failures:
            error('\n'.join(bad_orders))
            raise SystemExit(-1)
    finally:
        if lock:
            lock.release()


# helpers
OE = PropertyDict()

fis_module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

class OrderState(IntEnum):
    draft = 1
    scheduled = 2
    appt = 3
    ready = 4
    checked_in = 5
    complete = 6
    cancelled = 7
globals().update(OrderState.__members__)

class BadFormat(Exception):
    "order is incomplete"

class MissingPartner(Exception):
    "unable to find partner"

class CancelledOrder(Exception):
    "order has been cancelled"

class MissingFIS(Exception):
    "unable to find document in FIS"

def archive(src_file, dest=ARCHIVE):
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    existing = dest.glob(basename+'*')
    existing.sort()
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].split('_')
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)

def construct_datetime(appt_date, appt_time):
    date = time = None
    if appt_date:
        try:
            date = Date(appt_date)
        except ValueError:
            # error('Invalid Date: %r' % appt_date)
            raise ValueError('Invalid Date:  %r' % appt_date)
    if appt_time:
        # may see an invalid time
        try:
            time = Time.strptime(appt_time, '%H:%M')
        except ValueError:
            # try a float conversion
            try:
                time = Time.fromfloat(float(appt_time))
            except ValueError:
                # error('Invalid Time:  %r' % appt_time)
                raise ValueError('Invalid Time:  %r)' % appt_time)
    if date and time:
        # we have all the pieces, make a datetime
        dt = DateTime.combine(date, time, tzinfo=LOCAL_TIME)
    elif date:
        # we have a date, set time to midnight
        dt = DateTime.combine(date, Time(0), tzinfo=LOCAL_TIME)
    else:
        raise ValueError('Invalid Date/Time', 'Either both Date and Time should be specified, or neither')
    return dt

def get_order(order):
    g = {}
    try:
        execfile(order, g)
    except SyntaxError, exc:
        raise BadFormat(str(exc))
    if 'order' not in g:
        raise BadFormat('empty file?')
    return PropertyDict(g['order'])

def sync_openerp(orders):
    connect_oe(HOST, DB, USER, PW)
    print('looking up shipping records with date/time but no appt...')
    domain=[
        ('appointment_date','!=',False),
        ('state','!=','cancelled'),
        ]
    if orders:
        domain.append(('local_source_document','in',orders))
    targets = OE.fnx_shipping.search_read(
            fields=['id', 'appointment', 'appointment_date', 'appointment_time'],
            domain=domain,
            )
    pool = defaultdict(list)
    for t in ViewProgress(
            targets,
            'sorting $total records',
            view_type='bar',
        ):
        pool[t.appointment_date, t.appointment_time].append(t.id)
    for date_time, ids in ViewProgress(
            pool.items(),
            'updating $total groups',
            view_type='bar',
        ):
        date, time = date_time
        try:
            appt = construct_datetime(date, time)
        except (TypeError, ValueError):
            error(
                    'invalid date/time:< %r %r >.  skipping %d records: %s'
                    % (
                        date,
                        time,
                        len(ids),
                        ', '.join([str(i) for i in ids]),
                    ))
            raise
            continue
        OE.fnx_shipping.write(ids, {'appointment': appt}, context={'message_track': False})

def sync_fis(show_missing, reopen, orders):
    """
    updates status to complete/cancelled, ship date to FIS, BoL to FIS
    """
    print('connecting to OpenERP')
    connect_oe(HOST, DB, USER, PW)
    print('gathering orders from FIS')
    fis_orders = fisData(36, subset='10%6s')
    print('gathering purchases from FIS')
    fis_purchases = fisData(219, subset='10%5s')
    print('gathering orders from OpenERP')
    #
    # oi = open invoices; op = open purchases; ci = closed invoices; cp = closed purchased
    oi_dmn = [('state','not in', ['cancelled', 'complete']),('direction','=','outgoing')]
    op_dmn = [('state','not in', ['cancelled', 'complete']),('direction','=','incoming')]
    ci_dmn = [('state','in', ['cancelled', 'complete']),('direction','=','outgoing'),('check_out','=',False)]
    cp_dmn = [('state','in', ['cancelled', 'complete']),('direction','=','incoming'),('check_out','=',False)]
    if orders:
        for dmn in (oi_dmn, op_dmn, ci_dmn, cp_dmn):
            dmn.append(('local_source_document','in',orders))
    open_invoices = OE.fnx_shipping.search_read(
            fields=['id', 'ship_date', 'local_source_document', 'state'],
            domain=oi_dmn,
            )
    open_purchases = OE.fnx_shipping.search_read(
            fields=['id', 'local_source_document', 'state'],
            domain=op_dmn,
            )
    closed_invoices = OE.fnx_shipping.search_read(
            fields=['id', 'local_source_document', 'state'],
            domain=ci_dmn,
            )
    closed_purchases = OE.fnx_shipping.search_read(
            fields=['id', 'local_source_document', 'state'],
            domain=cp_dmn,
            )
    completed = {}
    cancelled = {}
    reopened = {}
    missing_invoices = []
    missing_purchases = []
    erp_documents = set()
    # order status
    for order in ViewProgress(
            open_invoices,
            'sorting $total invoices',
            view_type='bar',
        ):
        erp_documents.add(order.local_source_document)
        found = fis_orders.get_subset(order.local_source_document)
        status = 'not found'
        for key, record in found:
            # will only be one record, if any
            status = record[F36.inv_flag].upper()
            if status == 'B':
                continue
            elif status == 'V':
                cancelled[order.id] = order.local_source_document
                logger.debug('%6s: status -> %r [cancelling]', order.local_source_document, status)
            else:
                logger.debug('%6s: status -> %r [no action]', order.local_source_document, status)
            break
        else:
            logger.debug('%6s: status -> %r [completing]', order.local_source_document, status)
            completed[order.id] = order.local_source_document
    for order in ViewProgress(
            open_purchases,
            'sorting $total purchase orders',
            view_type='bar',
        ):
        erp_documents.add(order.local_source_document)
        found = fis_purchases.get_subset(order.local_source_document)
        reg_flag = None
        confirmed = None
        for key, record in found:
            reg_flag = record[F219.po_reg_flag].upper()
            confirmed = record[F219.confirmed_flag].upper()
            if reg_flag == 'V':
                logger.debug(
                        '%6s: reg_flag -> %r   confirmed -> %r [cancelling]',
                        order.local_source_document, reg_flag, confirmed,
                        )
                cancelled[order.id] = order.local_source_document
            elif confirmed == '3':
                continue
            else:
                logger.debug(
                        '%6s: reg_flag -> %r   confirmed -> %r [no action]',
                        order.local_source_document, reg_flag, confirmed,
                        )
            break
        else:
            logger.debug(
                    '%6s: reg_flag -> %r   confirmed -> %r [completing]',
                    order.local_source_document, reg_flag, confirmed,
                    )
            completed[order.id] = order.local_source_document
    if reopen:
        for order in ViewProgress(
                closed_invoices,
                'checking $total completed orders',
                view_type='bar',
            ):
            erp_documents.add(order.local_source_document)
            found = fis_orders.get_subset(order.local_source_document)
            for key, record in found:
                # will only be one record, if any
                status = record[F36.inv_flag].upper()
                # print('document %s: %r' % (order.local_source_document, status))
                if status in ('B', 'V'):
                    # already closed/cancelled, no need to change anything
                    break
                else:
                    reopened[order.id] = order.local_source_document
        for order in ViewProgress(
                closed_purchases,
                'checking $total completed purchase orders',
                view_type='bar',
            ):
            erp_documents.add(order.local_source_document)
            found = fis_purchases.get_subset(order.local_source_document)
            for key, record in found:
                reg_flag = record[F219.po_reg_flag].upper()
                confirmed = record[F219.confirmed_flag].upper()
                if reg_flag == 'V' or confirmed == '3':
                    # already closed/cancelled, no need to change anything
                    break
                else:
                    reopened[order.id] = order.local_source_document
    if cancelled:
        OE.fnx_shipping.write(cancelled.keys(), {'state': 'cancelled'})  #, context={'message_track': False})
    if completed:
        OE.fnx_shipping.write(completed.keys(), {'state': 'complete'})  #, context={'message_track': False})
    if reopened:
        OE.fnx_shipping.write(reopened.keys(), {'check_in': False, 'check_out': False}, context={'reopen': True})
    # dates
    changed_shipping = 0
    still_open_invoices = OE.fnx_shipping.search_read(
            fields=[
                'id', 'ship_date', 'local_source_document', 'state', 'partner_number',
                'ship_to_code', 'order_date', 'wanted_date',
                ],
            domain=oi_dmn,
            )
    for order in ViewProgress(
            still_open_invoices,
            'checking $total invoices for changed dates',
            view_type='bar',
        ):
        found = fis_orders.get_subset(order.local_source_document)
        for key, record in found:
            fis_data = PropertyDict()
            # will only be one record
            try:
                fis_ship_date = fix_date(record[F36.ship_date], format='ymd')
            except ValueError:
                # bad date skip
                logger.debug(
                        '%6s: ship-date -> %r [bad data, no action]',
                        order.local_source_document, record[F36.ship_date],
                        )
                fis_ship_date = False
            fis_data.partner_number = record[F36.cust_no]
            fis_data.ship_to_code = record[F36.ship_to_id]
            fis_data.order_date = fix_date(record[F36.order_date], format='ymd')
            fis_data.wanted_date = fix_date(record[F36.date_wanted], format='ymd')
            fis_data.ship_date = fis_ship_date
            values = {}
            for setting, fis_value in fis_data.items():
                if fis_value and order[setting] != fis_value:
                    values[setting] = fis_value
            if values:
                OE.fnx_shipping.write(order.id, pfm(values))
    still_open_purchases = OE.fnx_shipping.search_read(
            fields=['id', 'ship_date', 'local_source_document', 'state'],
            domain=op_dmn,
            )
    for order in ViewProgress(
            still_open_purchases,
            'checking $total purchases for changed dates',
            view_type='bar',
        ):
        found = fis_purchases.get_subset(order.local_source_document)
        logger.debug('looking for %s, found %d matches' % (order.local_source_document, len(found)))
        for key, record in found:
            # will only be one record
            try:
                fis_eta_date = fix_date(record[F219.eta_date], format='ymd')
            except ValueError:
                # bad date skip
                logger.debug(
                        '%6s: ship-date -> %r [bad data, no action]',
                        order.local_source_document, record[F219.eta_date],
                        )
                continue
            erp_eta_date = date(order.ship_date)
            if fis_eta_date is not None and fis_eta_date != erp_eta_date:
                fis_eta_date = fis_eta_date.strftime('%Y%m%d')
                changed_shipping += 1
                logger.debug(
                        '%6s: ship-date -> %r [updating]',
                        order.local_source_document, fis_eta_date,
                        )
                OE.fnx_shipping.write(order.id, {'ship_date':fis_eta_date})
            else:
                logger.debug(
                        '%6s: ship-date -> %r [no data, no action]',
                        order.local_source_document, record[F219.eta_date],
                        )
    # missing orders
    if show_missing:
        for record in ViewProgress(
                fis_orders,
                'searching for missing invoices',
                view_type='bar',
            ):
            order_no = record[F36.order_no]
            if orders and order_no not in orders:
                continue
            elif order_no and order_no not in erp_documents:
                missing_invoices.append(order_no)
        for record in ViewProgress(
                fis_purchases,
                'searching for missing purchase orders',
                view_type='bar',
            ):
            order_no = record[F219.po_no]
            if orders and order_no not in orders:
                continue
            elif order_no and order_no not in erp_documents:
                missing_purchases.append(order_no)
        missing_invoices.sort()
        missing_purchases.sort()
    #update BoL data
    order_nos = [
            fo[F36.order_no]
            for fo in fis_orders.values()
            ]
    invoices = dict([
        (r.local_source_document, r)
        for r in get_records(
            OE.fnx_shipping,
            domain=[('local_source_document','in',order_nos)],
            fields=['id','carrier_bill_of_lading','local_source_document'],
            )])
    bol_update = 0
    for order in fis_orders.values():
        order_no = order[F36.order_no]
        try:
            oe_rec = invoices[order_no]
        except KeyError:
            if not order_no.startswith('C'):
                error('unable to find', order_no)
            continue
        id = oe_rec.id
        bol = oe_rec.carrier_bill_of_lading
        if bol != order[F36.bol_no]:
            OE.fnx_shipping.write(id, {'carrier_bill_of_lading': order[F36.bol_no]})
            bol_update += 1

    print('completed %d orders' % len(completed))
    print('cancelled %d orders' % len(cancelled))
    print('dates synced with FIS:', changed_shipping)
    print('BoL updates: %d' % bol_update)
    if reopen:
        print('reopened %d orders' % len(reopened))
    if show_missing:
        echo()
        echo('missing invoices:', ', '.join(missing_invoices))
        echo()
        echo('missing purchase orders:', ', '.join(missing_purchases))


def update_order(values):
    # carrier is the shipping agent
    # partner is the vendor/customer
    # partner_source_document is the vendor invoice number / customer purchase order
    # local_source_document is our purchase order / invoice number
    # local_contact is the falcon user
    #
    # look for existing shipping record
    context = {'active_test': False}
    orders = OE.fnx_shipping.search_read(
            fields=['id','partner_number','ship_to_code','order_date','wanted_date','ship_date'],
            domain=[('local_source_document','=',values.local_source_document)],
            context=context,
            )
    if len(orders) > 1:
        raise ValueError(
                'found more than one shipping record matching %r: %r'
                % (values.local_source_document, [r.id for r in orders])
                )
    elif len(orders) == 1:
        oe_record = orders[0]
    else:
        oe_record = None
    print('  shipping record:', oe_record, verbose=2)
    #
    # appointment_date -> 20140107
    #
    # FIXME: appointment_date is actually an estimated ship date -- manually changing that
    # field until the update file is corrected

    if 'appointment_date' in values:
        values.ship_date = values.pop('appointment_date')
    #
    # carrier_xmlid --> 99
    # cartons --> 9
    # direction --> outgoing
    # local_contact --> 'sysadmin', 'rgiannini', 'ethan']
    # local_source_document --> 999999
    # pallets --> 3
    # partner_source_document --> PO TEST
    # partner_xmlid --> AWGRO
    # weight --> 139
    print('------', verbose=2)
    print('processsing shipping record for:  %7s...' % (values.local_source_document,), end=' ')
    print('\n%s' % values, verbose=3)
    original_values = values.copy()
    #
    # check for local document
    #
    if not values.local_source_document:
        raise BadFormat('missing local source document')
    local_contacts = values.pop('local_contact', None)
    print('\n  local_contacts:', local_contacts, verbose=2)
    #
    # check for local contacts
    #
    if local_contacts is not None:
        local_contacts = [lc for lc in set(local_contacts) if lc not in ('sysadmin', 'rgiannini')]
        records = OE.res_users.search_read(fields=['id', 'partner_id'], domain=[('login','in',local_contacts)], context=context)
        print('  found:\n', '\n'.join(repr(r) for r in records), verbose=2)
        values.message_follower_ids = [lc['partner_id'][0] for lc in records]
        if records:
            values.local_contact_id = records[0]['partner_id']
    partner_xmlid = values.pop('partner_xmlid', None)
    if partner_xmlid is not None:
        records = OE.res_partner.search_read(
                fields=['id', 'module', 'xml_id'],
                domain=[('module','=',fis_module[values.direction]),('xml_id','=',partner_xmlid)],
                context=context,
                )
        if not records:
            records = OE.res_partner.search_read(
                    fields=['id', 'module', 'xml_id'],
                    domain=[('xml_id','=',partner_xmlid)],
                    context=context,
                    )
            if not records:
                raise MissingPartner('unable to find partner %r in OpenERP' % partner_xmlid)
        partner_id = records[0]['id']
        values.partner_id = context['default_partner_id'] = partner_id
    #
    # check carrier
    #
    carrier_xmlid = values.pop('carrier_xmlid', None)
    if carrier_xmlid not in (None, ):
        carrier_id = oe_carriers.get(carrier_xmlid)
        if carrier_id is None:
            raise MissingPartner('unable to find carrier %r in OpenERP' % carrier_xmlid)
        values.carrier_id = carrier_id
    # 
    # check cartons, pallets, weight
    #
    if 'cartons' in values:
        values.cartons = int(values.cartons) or False
    if 'pallets' in values:
        values.pallets = int(values.pallets) or False
    if 'weight' in values:
        values.weight = float(values.weight) or False
    #
    # check direction
    #
    direction = values.get('direction')
    if direction is None:
        if (
            'cartons' in values
            or 'pallets' in values
            or 'weight' in values
            or len(values.local_source_document) == 6
        ):
            direction = 'outgoing'
        else:
            direction = 'incoming'
    if direction == 'incoming':
        values.job_title = values.preposition = values.partner_source_document_type = 'purchasing'
    elif direction == 'outgoing':
        values.job_title = values.preposition = values.partner_source_document_type = 'sales'
    #
    # check for sales rep
    #
    login = values.pop('user', None)
    if login:
        records = OE.res_users.search_read(fields=['id'], domain=[('login','=',login)])
        values.login_id = records[0]['id']
    #
    # find matching FIS record and grab needed values
    #
    extra = PropertyDict()
    if direction == 'outgoing':
        # invoice
        found = fis_orders.get_subset(values.local_source_document)
        if len(found) > 1:
            raise ValueError(
                    'found more than one invoice matching %r: %r'
                    % (values.local_source_document, [r.id for r in found])
                    )
        elif len(found) == 1:
            fis_record = found[0][1]
            extra.partner_number = fis_record[F36.cust_no] or False
            extra.ship_to_code = fis_record[F36.ship_to_id] or False
            extra.order_date = fix_date(fis_record[F36.order_date], format='ymd')
            extra.wanted_date = fix_date(fis_record[F36.date_wanted], format='ymd')
            extra.ship_date = fix_date(fis_record[F36.ship_date], format='ymd')
        else:
            if oe_record is None and values.get('state') not in ('complete','cancelled'):
                echo(
                        'unable to find invoice %r in FIS'
                            % (values.local_source_document, ),
                        end='... ',
                        )
                print('\n   details: %r' % (original_values, ), verbose=2)
    elif direction == 'incoming':
        # purchase order
        found = fis_purchases.get_subset(values.local_source_document)
        if len(found) > 1:
            raise ValueError(
                    'found more than one purchase order matching %r: %r'
                    % (values.local_source_document, [r.id for r in found])
                    )
        elif len(found) == 1:
            fis_record = found[0][1]
            extra.partner_number = fis_record[F219.supplier_no]
            extra.order_date = fix_date(fis_record[F219.order_date], 'ymd')
            extra.wanted_date = fix_date(fis_record[F219.date_wanted].replace('/',''), 'mdy')
            extra.ship_date = fix_date(fis_record[F219.eta_date], 'ymd')
        else:
            if oe_record is None and values.get('state') not in ('complete','cancelled'):
                echo(
                        'unable to find purchase order %r in FIS'
                            % (values.local_source_document, ),
                        end='... ',
                        )
                print('\n   details: %r' % (original_values, ), verbose=2)
    else:
        raise Exception('failed to calculate direction for %r' % (original_values, ))
    #
    # update values with FIS information:
    #
    if not oe_record:
        # add all extra info from FIS
        values.update(extra)
        try:
            print('  creating:\n', values, verbose=2)
            OE.fnx_shipping.create(pfm(values), context=dict(context))
            print('  created')
        except xmlrpclib.ProtocolError, exc:
            print('  failed')
            raise BadFormat('Order %s: %s' % (values.local_source_document, (exc)))
        except Exception, exc:
            print('  failed')
            error(exc)
            raise
    else:
        # add changed info from FIS
        for setting, new_value in extra.items():
            if oe_record[setting] != new_value:
                values[setting] = new_value
        try:
            print('  updating:', values.items(), verbose=2)
            OE.fnx_shipping.write([oe_record['id']], pfm(values))
            print('  updated')
        except xmlrpclib.ProtocolError, exc:
            print('  failed')
            raise BadFormat('Order %s: %s' % (values.local_source_document, (exc)))
        except xmlrpclib.Fault, exc:
            if 'This shipping record has been cancelled.' in str(exc):
                print('  shipping record has been cancelled')
                raise CancelledOrder('Order has been cancelled [id: %s]' % (oe_record['id'],))
            else:
                print('  failed')
                raise
        except Exception, exc:
            print('  failed')
            error(exc)
            raise

def get_files(source=SOURCE):
    files = [source/f for f in source.listdir() if f != 'order_template']
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def connect_oe(hostname, database, user, password):
    OE.conn = conn = get_connection(hostname=hostname, database=database, login=user, password=password)
    OE.res_partner = conn.get_model('res.partner')
    OE.res_users = conn.get_model('res.users')
    OE.fnx_shipping = conn.get_model('fnx.sr.shipping')


order_template = {
    'ship_date': False,
    'carrier_xmlid': False,
    'cartons': False,
    'direction': False,
    'local_contact': False,
    'local_source_document': False,
    'pallets': False,
    'partner_source_document': False,
    'partner_xmlid': False,
    'weight': False,
    }

def get_order_step(filename):
    g = {}
    step = filename.rsplit('_')[-1]
    execfile(filename, g)
    if 'order' not in g:
        raise Exception('empty file?')
    order = g['order']
    order['step'] = int(step)
    return order

def load_order(*filenames):
    order = []
    for fn in sorted(filenames):
        order.append(get_order_step(fn))
    return order

def print_table(*dicts):
    col_headers = set()
    col_widths = defaultdict(int)
    for d in dicts:
        for k in d.keys():
            if k == 'local_contact':
                continue
            col_headers.add(k)
            width = len(k)
            if k == 'state':
                width = 10
            col_widths[k] = max(col_widths[k], width)
    col_widths['state'] = 10
    col_headers = sorted(col_headers)
    col_headers.remove('step')
    col_headers.insert(0, 'step')
    header = []
    for h in col_headers:
        header.append('%-*s' % (col_widths[h], h))
    echo('   '.join(header))
    last_dict = {}
    for step, order in enumerate(dicts, start=1):
        print('examining dict %r: %r' % (step, order), verbose=3)
        line = []
        for col in col_headers:
            val = order.get(col, '.')
            if val is not False and val == last_dict.get(col):
                val = '='
            line.append('%-*s' % (col_widths[col], val))
        echo(' ' + '   '.join(line))
        last_dict = order


def pfm(values):
    "prepare values dict for marshalling"
    result = {}
    for k, v in values.items():
        if not v:
            result[k] = False
        elif isinstance(v, Date):
            result[k] = v.strftime(DEFAULT_SERVER_DATE_FORMAT)
        elif isinstance(v, Many2One):
            result[k] = v.id
        elif isinstance(v, Enum):
            result[k] = v.value
        else:
            result[k] = v
    return result


with user_ids(0, 0):
    Main()
