#!/usr/bin/env python

from scription import Script, Command, Run, mail
from syslog import syslog
from VSS import Date
from VSS.path import Path, listdir, glob
from VSS.time_machine import PropertyDict
from VSS.utils import ProgressBar, Enum, IntEnum, AutoEnum
import openerplib
import shutil
import time

SOURCE = Path('/var/fis/')
ARCHIVE = Path('/var/openerp/archive/shipping/')
ERRORS = Path('/var/openerp/archive/shipping/error')
USER_PW_DB = Path('/etc/openerp/credentials')

execfile(USER_PW_DB)

OE = PropertyDict()

module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

class OrderState(IntEnum):
    draft = 1
    scheduled = 2
    appt = 3
    ready = 4
    checked_in = 5
    complete = 6
    cancelled = 7
globals().update(OrderState.__members__)

class BadFormat(Exception):
    "order is incomplete"

class MissingPartner(Exception):
    "unable to find partner"

def archive(src_file, dest=ARCHIVE):
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    existing = glob(dest/basename+'*')
    existing.sort()
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].split('_')
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)

def get_order(order):
    g = {}
    execfile(order, g)
    return PropertyDict(g['order'])

def update_order(values):
    if not values.local_source_document:
        raise BadFormat('missing local source document')
    local_contacts = values.pop('local_contact', None)
    if local_contacts is not None:
        if 'sysadmin' in local_contacts:
            local_contacts.remove('sysadmin')
        records = OE.res_users.search_read(fields=['id'], domain=[('login','in',local_contacts)])
        values.local_contact_ids = [lc['id'] for lc in records]
    partner_xmlid = values.pop('partner_xmlid', None)
    if partner_xmlid is not None:
        records = OE.res_partner.search_read(fields=['id', 'module', 'xml_id'], domain=[('module','=',module[values.direction]),('xml_id','=',partner_xmlid)])
        if not records:
            raise MissingPartner('unable to find partner %r' % partner_xmlid)
        partner_id = records[0]['id']
        values.partner_id = partner_id
    carrier_xmlid = values.pop('carrier_xmlid', None)
    if carrier_xmlid not in (None, ):
        records = OE.res_partner.search_read(fields=['id'], domain=[('module','=',module['carrier']),('xml_id','=',carrier_xmlid)])
        if not records:
            records = OE.res_partner.search_read(fields=['id'], domain=[('module','=',module['carrier']),('xml_id','=','99')])
            if not records:
                raise MissingPartner('unable to find carrier %r' % carrier_xmlid)
        carrier_id = records[0]['id']
        values.carrier_id = carrier_id
    direction = values.get('direction')
    if direction == 'incoming':
        values.job_title = values.preposition = values.partner_source_document_type = 'purchasing'
    elif direction == 'outgoing':
        values.job_title = values.preposition = values.partner_source_document_type = 'sales'
    if 'cartons' in values:
        values.cartons = int(values.cartons) or False
    if 'pallets' in values:
        values.pallets = int(values.pallets) or False
    if 'weight' in values:
        values.weight = float(values.weight) or False
    orders = OE.fnx_shipping.search_read(fields=['id', 'appt_confirmed', 'state'], domain=[('local_source_document','=',values.local_source_document)])
    order = None
    for order in orders:
        break
    if not order and not direction:
        raise BadFormat('cannot create new document %r without a direction' % values.local_source_document)
    elif not order:
        values.state = 'draft'
    elif 'pallets' in values and values.pallets:
        if order['state'] in ('checked_in', 'complete', 'cancelled'):
            pass
        elif order['state'] == 'scheduled':
            values.state = 'ready'
        else:
            values.state = 'appt'
    login = values.pop('user', None)
    if login:
        records = OE.res_users.search_read(fields=['id'], domain=[('login','=',login)])
        values.login_id = records[0]['id']
    if not order:
        try:
            OE.fnx_shipping.create(dict(values))
        except Exception, exc:
            print(exc.faultCode)
            print
    else:
        try:
            OE.fnx_shipping.write([order['id']], dict(values))
        except Exception, exc:
            print(exc.faultCode)
            print

def get_files(source=SOURCE):
    files = [SOURCE/f for f in SOURCE.listdir() if f != 'order_template']
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def connect_oe(hostname, database, user, password):
    OE.conn = conn = openerplib.get_connection(hostname=hostname, database=database, login=user, password=password)
    OE.res_partner = conn.get_model('res.partner')
    OE.res_users = conn.get_model('res.users')
    OE.fnx_shipping = conn.get_model('fnx.sr.shipping')

@Command(
        remove=('remove identical duplicates', 'flag', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def find_duplicates(hostname='localhost', db=DB, login=USER, password=PW, remove=False):
    """Look for duplicate orders; print any found"""
    connect_oe(hostname, db, login, password)
    records = OE.fnx_shipping.search_read(fields=['id', 'local_source_document'], )
    order_numbers = set()
    duplicates = list()
    removed = list()
    removed_ids = list()
    pb = ProgressBar(len(records), message="processing %d records" % len(records))
    for sr in records:
        pb.tick()
        sr = PropertyDict(sr)
        if sr.local_source_document in order_numbers:
            duplicates.append(sr.local_source_document)
        else:
            order_numbers.add(sr.local_source_document)
    if duplicates:
        print '\n%d duplicates found in %d orders:\n' % (len(duplicates), len(records))
        if remove:
            pb = ProgressBar(len(duplicates), message='checking %d records' % len(duplicates))
            for dup in duplicates:
                pb.tick()
                dups = OE.fnx_shipping.search_read(domain=[('local_source_document','=',dup)])
                if len(dups) > 2:
                    continue
                d0 = PropertyDict(dups[0])
                d1 = PropertyDict(dups[1])
                d0_state = OrderState[d0.state]
                d1_state = OrderState[d1.state]
                d0_msgs = len(d0.message_ids)
                d1_msgs = len(d1.message_ids)
                if ( ( d0_state != complete and d1_state == complete)
                  or ( d0_state == complete and d1_state != complete)
                  ):
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                elif d0_state > d1_state:
                    removed.append(d1.local_source_document)
                    removed_ids.append(d1.id)
                elif d1_state > d0_state:
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                elif d0_msgs > d1_msgs:
                    removed.append(d1.local_source_document)
                    removed_ids.append(d1.id)
                elif d1_msgs > d0_msgs:
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                else:
                    d0_id = d0.pop('id')
                    d1_id = d1.pop('id')
                    d0.pop('message_ids')
                    d1.pop('message_ids')
                    if d0 == d1:
                        removed.append(d1.local_source_document)
                        removed_ids.append(d1_id)
            if removed:
                duplicates = [lsd for lsd in duplicates if lsd not in removed]
                OE.fnx_shipping.unlink(removed_ids)
                print '\n'
            for r in removed:
                print '\t', r
            print '\n\nremaining...'
        for dup in sorted(duplicates):
            print '\t', dup
    else:
        print '\nNo duplicates found.\n'

@Command(
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def fix_carriers(hostname='localhost', db=DB, login=USER, password=PW):
    """compare OE values for carrier with values in files -- if OE value is '99'
    and file value is not, set to file value"""
    connect_oe(hostname, db, login, password)
    records = OE.res_partner.search_read(fields=['id'], domain=[('module','=',module['carrier']),('xml_id','=','99')])
    unknown_id = records[0]['id']
    records = OE.res_partner.search_read(fields=['id','xml_id'], domain=[('module','=',module['carrier'])])
    shippers = {}
    for rec in records:
        shippers[rec['xml_id']] = rec['id']
    shipping_records = OE.fnx_shipping.search_read(
            fields=['id','carrier_id','local_source_document'],
            domain=['|',('carrier_id.id','=',unknown_id),('carrier_id','=',False)])
    pb = ProgressBar(len(shipping_records), message="processing %d records" % len(shipping_records))
    for sr in shipping_records:
        pb.tick()
        sr = PropertyDict(sr)
        source_files = sorted((ARCHIVE / sr.local_source_document + '*').glob())
        order = PropertyDict()
        for sf in source_files:
            settings = get_order(sf)
            order.update(settings)
        carrier_xmlid = order.get('carrier_xmlid')
        if carrier_xmlid in shippers:
            carrier_id = shippers[carrier_xmlid]
            values = {'carrier_id':carrier_id}
            OE.fnx_shipping.write([sr.id], values)

@Command(
        values=('settings to use', 'keyword', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def manual_update(hostname='localhost', db=DB, login=USER, password=PW, **values):
    connect_oe(hostname, db, login, password)
    update_order(PropertyDict(values))

@Command(
        file_to_process=('order to add/update in system', ),
        hostname=('host where OpenERP instance is running', ),
        db=('database to use', ),
        login=('login name to use', ),
        password=('password for login name', ),
        )
def update(file_to_process='', hostname='localhost', db=DB, login=USER, password=PW):
    if file_to_process:
        files = [file_to_process]
    else:
        files = get_files()
    connect_oe(hostname, db, login, password)
 
    retry = []
    failed = []
    for group in ((files, failed), ):
        time.sleep(5)
        trying, failing = group
        for file in trying:
            try:
                order = get_order(file)
                update_order(order)
                dest = ARCHIVE
            except (BadFormat, MissingPartner, ), exc:
                failing.append('%s: %s' % (file, exc.message or exc.args))
                dest = ERRORS
            except (IOError, ), exc:
                failing.append('%s: %s' % (file, exc.message or exc.args))
                continue
            archive(file, dest)
    if failed:
        raise Exception("Unable to process orders:\n\t%s" % '\n\t'.join(failed))

if __name__ == '__main__':
    Run()
