#!/usr/bin/env python

# setup
from __future__ import print_function

from collections import defaultdict
from dbf import Date, DateTime, Time
from enum import IntEnum
from pandaemonium import PidLockFile, AlreadyLocked
from pytz import timezone
from scandir import scandir
from scription import *
from VSS.BBxXlate.fisData import fisData
from VSS.utils import grouped, fix_date, date
from antipathy import Path
from VSS.time_machine import PropertyDict
from VSS.utils import ProgressBar
from VSS.constants import Enum
import logging
from openerplib import get_connection, get_records
import shutil
import socket
import time
import xmlrpclib

logging.basicConfig(
        filename='/var/log/openerp/fnx_sr.log',
        level=logging.DEBUG,
        format='%(process)06d %(asctime)s %(name)-25s %(message)s',
        )

SOURCE = Path('/var/fis/')
ARCHIVE = Path('/var/openerp/archive/shipping/')
ERRORS = Path('/var/openerp/archive/shipping/error')
CONFIG = Path('/etc/openerp/fnx.ini')

try:
    settings = OrmFile(CONFIG, section='openerp')
except Exception:
    print('WARNING: unable to process configfile; all parameters must be specified', verbose=0)
    HOST = ''
    USER = ''
    DB = ''
    PW = ''
else:
    HOST = settings.host
    USER = settings.user
    DB = settings.db
    PW = settings.pw

# set later
draft = scheduled = appt = ready = checked_in = complete = cancelled = None

# API
@Script(
        host=('host where OpenERP instance is running', OPTION),
        db=('database to use', OPTION),
        user=('login name to use', OPTION),
        pw=('password for login name', OPTION),
        )
def main(host, db, user, pw):
    if host:
        module.HOST = host
    if db:
        module.DB = db
    if user:
        module.USER = user
    if pw:
        module.PW = pw
    for req in ('HOST', 'USER', 'DB', 'PW'):
        if not module[req]:
            raise SystemExit('%r required; use --help for more info' % req)
    global logger
    logger = logging.getLogger('orders')

@Command(
        remove=('remove identical duplicates', 'flag', ),
        )
def find_duplicates(remove=False):
    """Look for duplicate orders; print any found"""
    logging.info('find_duplicates(remove=%r)', remove)
    connect_oe(HOST, DB, USER, PW)
    records = OE.fnx_shipping.search_read(fields=['id', 'local_source_document'], )
    order_numbers = set()
    duplicates = list()
    removed = list()
    removed_ids = list()
    pb = ProgressBar(len(records), message="processing %d records" % len(records))
    for sr in records:
        pb.tick()
        sr = PropertyDict(sr)
        if sr.local_source_document in order_numbers:
            duplicates.append(sr.local_source_document)
        else:
            order_numbers.add(sr.local_source_document)
    if not duplicates:
        print('\nNo duplicates found.\n', verbose=0)
    else:
        print('\n%d duplicates found in %d orders:\n' % (len(duplicates), len(records)), verbose=0)
        if remove:
            pb = ProgressBar(len(duplicates), message='checking %d records' % len(duplicates))
            for dup in duplicates:
                pb.tick()
                dups = OE.fnx_shipping.search_read(domain=[('local_source_document','=',dup)])
                if len(dups) > 2:
                    continue
                d0 = PropertyDict(dups[0])
                d1 = PropertyDict(dups[1])
                d0_state = OrderState[d0.state]
                d1_state = OrderState[d1.state]
                d0_msgs = len(d0.message_ids)
                d1_msgs = len(d1.message_ids)
                if ( ( d0_state != complete and d1_state == complete)
                  or ( d0_state == complete and d1_state != complete)
                  ):
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                elif d0_state > d1_state:
                    removed.append(d1.local_source_document)
                    removed_ids.append(d1.id)
                elif d1_state > d0_state:
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                elif d0_msgs > d1_msgs:
                    removed.append(d1.local_source_document)
                    removed_ids.append(d1.id)
                elif d1_msgs > d0_msgs:
                    removed.append(d0.local_source_document)
                    removed_ids.append(d0.id)
                else:
                    d0.pop('id')
                    d1_id = d1.pop('id')
                    d0.pop('message_ids')
                    d1.pop('message_ids')
                    if d0 == d1:
                        removed.append(d1.local_source_document)
                        removed_ids.append(d1_id)
            if removed:
                duplicates = [lsd for lsd in duplicates if lsd not in removed]
                OE.fnx_shipping.unlink(removed_ids)
                print('\n', verbose=0)
            for r in removed:
                print('\t', r, verbose=0)
            print('\n\nremaining...', verbose=0)
        for dup in sorted(duplicates):
            print('\t', dup, verbose=0)


@Command()
def fix_carriers():
    """
    compare OE values for carrier with values in files -- if OE value is '99'
    and file value is not, set to file value
    """
    logger.info('fix_carriers()')
    connect_oe(HOST, DB, USER, PW)
    records = OE.res_partner.search_read(fields=['id'], domain=[('module','=',fis_module['carrier']),('xml_id','=','99')])
    unknown_id = records[0]['id']
    records = OE.res_partner.search_read(fields=['id','xml_id'], domain=[('module','=',fis_module['carrier'])])
    shippers = {}
    for rec in records:
        shippers[rec['xml_id']] = rec['id']
    shipping_records = OE.fnx_shipping.search_read(
            fields=['id','carrier_id','local_source_document'],
            domain=['|',('carrier_id.id','=',unknown_id),('carrier_id','=',False)])
    pb = ProgressBar(len(shipping_records), message="processing %d records" % len(shipping_records))
    for sr in shipping_records:
        pb.tick()
        sr = PropertyDict(sr)
        source_files = sorted((ARCHIVE / sr.local_source_document + '*').glob())
        order = PropertyDict()
        for sf in source_files:
            settings = get_order(sf)
            order.update(settings)
        carrier_xmlid = order.get('carrier_xmlid')
        if carrier_xmlid in shippers:
            carrier_id = shippers[carrier_xmlid]
            values = {'carrier_id':carrier_id}
            OE.fnx_shipping.write([sr.id], values)


@Command()
def info():
    logger.info('info()')
    print('loading OPAR', verbose=0)
    opar = fisData(54, subset='10%6s%6s')
    print('total OPAR records:', len(opar), verbose=0)
    opar_company = fisData(54, subset='%2s')
    print('OPAR possible matches:', len(opar_company.get_subset(('10',))), verbose=0)
    connect_oe(HOST, DB, USER, PW)
    print('getting partner records', verbose=0)
    partners = dict([
            (r.id, r.xml_id)
            for r in get_records(
                OE.res_partner,
                fields=['id', 'xml_id'],
                )
            ])
    print('getting orders', verbose=0)
    all_orders = get_records(
            OE.fnx_shipping,
            fields=['id', 'state', 'name', 'direction', 'appointment_date', 'partner_id', 'local_source_document'],
            )
    month = defaultdict(lambda: dict(total=0, outgoing=0, incoming=0, opar=0, draft=0, ready=0, loading=0, complete=0, cancelled=0, unknown=0))
    totals = dict(total=0, outgoing=0, incoming=0, opar=0, draft=0, ready=0, loading=0, complete=0, cancelled=0, unknown=0)
    pb = ProgressBar(len(all_orders), message="tallying orders")
    for order in all_orders:
        pb.tick()
        appt = order.appointment_date and order.appointment_date[:7] or False
        if opar.get_subset((partners[order.partner_id[0]], order.local_source_document)):
            month[appt]['opar'] += 1
            totals['opar'] += 1
        month[appt]['total'] += 1
        month[appt][order.direction] += 1
        if order.direction == 'outgoing':
            month[appt][order.state or 'unknown'] += 1
            totals[order.state or 'unknown'] += 1
        totals[order.direction] += 1
        totals['total'] += 1
    print('        | incoming  outgoing | open a/r | draft  ready  loading  complete  cancelled  unknown | totals', verbose=0)
    print('------- + --------  -------- + -------- + -----  -----  -------  --------  ---------  ------- + ------', verbose=0)
    template = '%(month)7s | %(incoming)8s  %(outgoing)8d | %(opar)8s | %(draft)5d  %(ready)5d  %(loading)7d  %(complete)8d  %(cancelled)9d  %(unknown)7d | %(total)6d'
    for month, counts in sorted(month.items()):
        counts['month'] = month or 'missing'
        print(template % counts, verbose=0)
    print('------- + --------  -------- + -----  -----  -------  --------  --------- + ------ + ------', verbose=0)
    template = '%(month)7s | %(incoming)8s  %(outgoing)8d | %(opar)8s | %(draft)5d  %(ready)5d  %(loading)7d  %(complete)8d  %(cancelled)9d  %(unknown)7d | %(total)6d'
    totals['month'] = 'all'
    print(template % totals, verbose=0)



@Command(
        values=('settings to use', ),
        )
def manual_update(**values):
    # values that need to be converted from str:
    #    local_contact -> list
    logger.info('manual_update(values=%r)', values)
    connect_oe(HOST, DB, USER, PW)
    lc = values.pop('local_contact', None)
    if lc is not None:
        values['local_contact'] = lc.split(',')
    update_order(PropertyDict(values))


@Command()
def missing_check():
    logger.info('missing_check()')
    connect_oe(HOST, DB, USER, PW)
    orders = dict(
            (item.local_source_document, item)
            for item in get_records(OE.fnx_shipping, fields=['id', 'local_source_document', 'partner_id'])
            )
    processed = [name.split('_')[0] for name in ARCHIVE.listdir()]
    for order in processed:
        if order not in orders:
            print(order, verbose=0)
    print(verbose=0)


@Command(
        dryrun=('display affected records instead of deleting them', FLAG),
        )
def purge(dryrun):
    """
    removes completed or out-of-date orders and their interface files

    criteria:
    - shipping, complete, more than 3 months old, and not in OPAR; or
    - receiving, complete, and more than 6 months old; or
    - more than 1 year old
    """
    logger.info('purge(dryrun=%r)', dryrun)
    print('connecting to %s:%s' % (HOST, DB))
    connect_oe(HOST, DB, USER, PW)
    print('loading OPAR')
    opar = fisData(54, subset='10%6s%6s')
    print('total OPAR records:', len(opar))
    opar_company = fisData(54, subset='%2s')
    print('OPAR possible matches:', len(opar_company.get_subset(('10',))))
    fields = ['id', 'local_source_document', 'partner_id']
    print('getting candidate shipped orders')
    shipped_orders = dict([(o.local_source_document, o)
            for o in get_records(
                OE.fnx_shipping,
                domain=[('direction','=','outgoing'),('state','in',['complete','cancelled']),('appointment_date','<','Month6')],
                fields=fields,
                )])
    print('getting candidate received orders')
    received_orders = dict([(o.local_source_document, o)
            for o in get_records(
                OE.fnx_shipping,
                domain=[('direction','=','incoming'),('state','in',['complete','cancelled']),('appointment_date','<','Month6')],
                fields=fields,
                )])
    print('getting aged-out incomplete orders')
    dead_orders = dict([(o.local_source_document, o)
            for o in get_records(
                OE.fnx_shipping,
                domain=[('state','not in',['complete','cancelled']),('appointment_date','<','Month12')],
                fields=fields,
                )])
    print('getting partner records')
    partners = dict([
            (r.id, r.xml_id)
            for r in get_records(
                OE.res_partner,
                fields=['id', 'xml_id'],
                )
            ])
    # check each shipped order to make sure it does not have an
    # open A/R invoice attached
    pb = ProgressBar(len(shipped_orders)+len(received_orders)+len(dead_orders), message="calculating dead orders")
    dead_shipped_ids = set()
    dead_received_ids = set()
    dead_ids = set()
    dead_files = set()
    all_dead_ids = set()
    for id_tracker, id_source, check_inv in (
            (dead_shipped_ids, shipped_orders, True),
            (dead_received_ids, received_orders, False),
            (dead_ids, dead_orders, False),
            ):
        for local_source_document, record in id_source.items():
            pb.tick()
            if check_inv and opar.get_subset((partners[record.partner_id[0]], local_source_document)):
                # open A/R invoices exist
                continue
            id_tracker.add(record.id)
            all_dead_ids.add(record.id)
    # find dead files
    # - get all records
    # - filter to live records
    # - mark non-live files
    all_orders = get_records(OE.fnx_shipping, fields=['local_source_document'])
    live_lsds = set([o.local_source_document for o in all_orders if o.id not in all_dead_ids])
    # error directory is "live"
    live_lsds.add('error')
    # all_order_ids = set([o.id for o in all_orders])
    # all_order_lsds = set([o.local_source_document for o in all_orders])
    dead_files = []
    for folder in (ARCHIVE, ERRORS):
        for entry in scandir(folder):
            entry = Path(entry.path)
            stem = entry.filename.split('_')[0]
            days_old = (DateTime.now() - DateTime.fromtimestamp(entry.stat().st_mtime)).days
            if stem not in live_lsds and days_old > 90:
                dead_files.append(entry)
    if dryrun:
        print('%d shipped candidates' % len(shipped_orders), verbose=0)
        print('%d dead shipped' % len(dead_shipped_ids), verbose=0)
        print('%d dead receivables' % len(received_orders), verbose=0)
        print('%d dead dead' % len(dead_orders), verbose=0)
        print('%d orphaned files' % len(dead_files), verbose=0)
    else:
        # delete the old stuff
        if dead_shipped_ids:
            # starting with the dead shipped
            print('removing %d shipped orders' % len(dead_shipped_ids))
            OE.fnx_shipping.unlink(list(dead_shipped_ids))
        if dead_received_ids:
            # and the old purchased orders
            print('removing %d received orders' % len(dead_received_ids))
            OE.fnx_shipping.unlink(list(dead_received_ids))
        if dead_ids:
            # and the seriously old stuff
            print('removing %d very old orders' % len(dead_ids))
            OE.fnx_shipping.unlink(list(dead_ids))
        if dead_files:
            # and then the interface files
            print('removing %d orphaned files' % len(dead_files))
            for entry in dead_files:
                entry.unlink()


@Command(
        file_to_process=('order to add/update in system', MULTI, 'f', Path, ),
        date=('reprocess all files from <date>', MULTI, 'd', Date, ),
        )
def reprocess(file_to_process, date):
    logger.info('reprocess(file_to_process=%r, date=%r', file_to_process, date)
    if not (file_to_process or date):
        raise SystemExit('either file(s) or date(s) must be specified')
    if file_to_process:
        files = [ARCHIVE/f for f in file_to_process]
    else:
        files = [
                f
                for f in get_files(ARCHIVE)
                if DateTime.fromtimestamp(f.stat().st_mtime).date() in date
                ]
    failed = []
    for file in files:
        try:
            order = get_order(file)
            update_order(order)
        except Exception, exc:
            failed.append((str(exc), file))
    if failed:
        raise Exception("Unable to re-process orders:\n\t%s" % '\n\t'.join(failed))

@Command()
def reprocess_error():
    """
    goes through the errors directory and reprocesses any orders that are
    either missing or still open
    """
    logger.info('reprocess_error()')
    connect_oe(HOST, DB, USER, PW)
    print('gathering orders from OpenERP...')
    orders = dict(
            (item.local_source_document, item)
            for item in get_records(OE.fnx_shipping, fields=['id', 'local_source_document', 'partner_id', 'state'])
            )
    candidates = ERRORS.glob('*')
    candidates.sort(key=lambda c: c.stat().st_ctime)
    for mishap in candidates:
        try:
            order = get_order(mishap)
        except BadFormat:
            continue
        oe_order = orders.get(order.local_source_document)
        if order.local_source_document[0].isalpha():
            # weird stuff, skip it
            continue
        if oe_order is not None and oe_order.state in ('complete', 'cancelled'):
            # it's closed, don't sweat it
            continue
        print('updating %s' % order.local_source_document)
        try:
            update_order(order)
        except MissingPartner:
            continue


@Command(
        date=('start date for missing orders', REQUIRED, 'd', Date),
        )
def reprocess_missing(date):
    logger.info('reprocess_missing(date=%r)', date)
    connect_oe(HOST, DB, USER, PW)
    print('gathering orders from OpenERP...',)
    orders = dict(
            (item.local_source_document, item)
            for item in get_records(OE.fnx_shipping, fields=['id', 'local_source_document', 'partner_id'])
            )
    print('(%d found)' % len(orders), orders.keys()[:10])
    print('gathering all orders from %s till today...' % date,)
    processed_ids = dict(
            (name.filename.split('_')[0], name)
            for name in (ARCHIVE/'*').glob()
            if Date.fromtimestamp(name.stat().st_ctime) >= date and not name.endswith('/error')
            )
    print('(%d found)' % len(processed_ids), processed_ids.keys()[:10])
    lock = PidLockFile('/var/run/fnxsr-order_update.pid', timeout=300)
    lock.seal()
    i = 0
    for order_id, order_file in sorted(processed_ids.items()):
        if order_id not in orders:
            print('re-adding order', order_id)
            i += 1
            order = get_order(order_file)
            update_order(order)
            order_file_timestamp = order_file.stat().st_ctime
            error_updates = sorted([
                    name
                    for name in (ERRORS/order_id+'*').glob()
                    if name.stat().st_ctime > order_file_timestamp
                    ])
            for err_update in error_updates:
                print('re-adding error', err_update)
                order = get_order(err_update)
                update_order(order)
            print()
            if i % 10:
                lock.release()
                print('letting system get a word in edgewise...')
                time.sleep(90)
                lock.seal()
                print('okay, processing some more')
    lock.release()


@Command(
        what=Spec('what to synchronize', choices=['erp', 'fis']),
        show_missing=Spec('show missing orders when syncing status', FLAG, 'm'),
        reopen=Spec('reopen closed orders', FLAG),
        orders=Spec('only affect these orders', OPTION),
        )
def sync(what, show_missing, reopen, *orders):
    '''
    synchronizes data either within OpenERP or with FIS
    '''
    logger.info('sync(what=%r, show_missing=%r, reopen=%r, orders=%r)', what, show_missing, reopen, orders)
    if what == 'erp':
        sync_openerp(orders)
    elif what == 'fis':
        sync_fis(show_missing, reopen, orders)


@Command(
        file=('order to add/update in system', OPTION, 'f', Path),
        directory=('directory of orders to add/update in system', OPTION, 'd', Path),
        )
def update(file, directory=SOURCE):
    """
    Add files with the structure of

        order={
          'appointment_date': '20140107',
          'carrier_xmlid': '99',
          'cartons': '9',
          'direction': 'outgoing',
          'local_contact': ['sysadmin', 'rgiannini', 'ethan'],
          'local_source_document': '999999',
          'pallets': 0,
          'partner_source_document': 'PO TEST',
          'partner_xmlid': 'AWGRO',
          'weight': '139',
          }

    to OpenERP.FnxSR.
    """
    logger.info('update(file=%r, directory=%r', file, directory)
    if file:
        files = [file]
        lock = None
    else:
        if not directory.exists():
            abort('directory %s does not exist' % directory)
        try:
            lock = PidLockFile('/var/run/fnxsr-order_update.pid', timeout=30)
            lock.seal()
        except AlreadyLocked:
            return
        files = get_files(directory)
        if not files:
            lock.release()
            return
    try:
        connect_oe(HOST, DB, USER, PW)
    except socket.error:
        if lock:
            lock.release()
        raise SystemExit('unable to connect to OpenERP server')
    try:
        failed = []
        failures = False
        bad_orders = []
        for group in ((files, failed), ):
            time.sleep(5)
            trying, failing = group
            for file in trying:
                try:
                    order = get_order(file)
                    if order.local_source_document[0].isalpha():
                        dest = ERRORS
                    else:
                        update_order(order)
                        dest = ARCHIVE
                except (BadFormat, MissingPartner, ), exc:
                    print('%s: %s' % (file, exc.message or exc.args), file=stderr)
                    with open(file) as f:
                        data = '================\n%s\n----------------' % file
                        data += f.read() + '\n'
                        bad_orders.append(data)
                    # failing.append('%s: %s' % (file, exc.message or exc.args))
                    dest = ERRORS
                    failures = True
                except (IOError, ), exc:
                    print('%s: %s' % (file, exc.message or exc.args), file=stderr)
                    # failing.append('%s: %s' % (file, exc.message or exc.args))
                    dest = None
                    failures = True
                    continue
                if dest:
                    archive(file, dest)
        if failures:
            # raise Exception("Unable to process orders:\n\t%s" % '\n\t'.join(failed))
            print('\n'.join(bad_orders), file=stderr)
            raise SystemExit(-1)
    finally:
        if lock:
            lock.release()


# helpers
OE = PropertyDict()

fis_module = {
    'incoming': 'F163',
    'outgoing': 'F33',
    'carrier':  'F27',
    }

class OrderState(IntEnum):
    draft = 1
    scheduled = 2
    appt = 3
    ready = 4
    checked_in = 5
    complete = 6
    cancelled = 7
globals().update(OrderState.__members__)

class BadFormat(Exception):
    "order is incomplete"

class MissingPartner(Exception):
    "unable to find partner"

def archive(src_file, dest=ARCHIVE):
    src_file = Path(src_file)
    basename = src_file.filename.split('_')[0]
    existing = dest.glob(basename+'*')
    existing.sort()
    if not existing or '_' not in existing[-1]:
        dst_file = dest/basename + '_01'
    else:
        dst_file, count = existing[-1].split('_')
        count = int(count) + 1
        dst_file += '_%02d' % count
    shutil.move(src_file, dst_file)

def construct_datetime(appt_date, appt_time):
    # XXX: change this hardcoded time zone after all users verified to not be in UTC
    # and res.users no longer has UTC as the default time zone
    # user_tz = timezone(get_user_timezone(self, cr, uid)[uid])
    user_tz = timezone('America/Los_Angeles')
    utc = timezone('UTC')
    date = time = None
    if appt_date:
        # will never see an invalid date due to javascript library
        date = Date(appt_date)
    if appt_time:
        # may see an invalid time
        try:
            time = Time.fromfloat(appt_time)
        except:
            raise ValueError('Invalid Time', 'Time should be between 0:00 and 23:59 (not %s)' % appt_time)
    if date and time:
        # we have all the pieces, make a datetime
        dt = DateTime.combine(date, time).datetime()
    elif date:
        # we have a date, set time to midnight
        dt = DateTime.combine(date, Time(0)).datetime()
    else:
        raise ValueError('Invalid Date/Time', 'Either both Date and Time should be specified, or neither')
    dt = user_tz.normalize(user_tz.localize(dt)).astimezone(utc)
    datetime = dt.strftime(DEFAULT_SERVER_DATETIME_FORMAT)
    return datetime

def get_order(order):
    g = {}
    try:
        execfile(order, g)
    except SyntaxError, exc:
        raise BadFormat(str(exc))
    if 'order' not in g:
        raise BadFormat('empty file?')
    return PropertyDict(g['order'])

def sync_openerp(orders):
    connect_oe(HOST, DB, USER, PW)
    print('looking up shipping records with date/time but no appt...')
    domain=[
        ('appointment_date','!=',False),
        ('state','!=','cancelled'),
        ]
    if orders:
        domain.append(('local_source_document','in',orders))
    targets = OE.fnx_shipping.search_read(
            fields=['id', 'appointment', 'appointment_date', 'appointment_time'],
            domain=domain,
            )
    pool = defaultdict(list)
    for t in ProgressView(
            iterable=targets,
            message='sorting $total records',
            view_type='bar',
        ):
        pool[t.appointment_date, t.appointment_time].append(t.id)
    for date_time, ids in ProgressView(
            iterable=pool.items(),
            message='updating $total groups',
            view_type='bar',
        ):
        date, time = date_time
        try:
            appt = construct_datetime(date, time)
        except ValueError:
            error('invalid date/time: %s %s.  skipping %d records' % (date, time, len(ids)))
            continue
        OE.fnx_shipping.write(ids, {'appointment': appt}, context={'message_track': False})

def sync_fis(show_missing, reopen, orders):
    """
    updates status to complete/cancelled, ship date to FIS
    """
    print('connecting to OpenERP')
    connect_oe(HOST, DB, USER, PW)
    print('gathering orders from FIS')
    fis_orders = fisData(36, subset='10%6s')
    print('gathering purchases from FIS')
    fis_purchases = fisData(219, subset='10%5s')
    print('gathering orders from OpenERP')
    oi_dmn = [('state','not in', ['cancelled', 'complete']),('direction','=','outgoing')]
    op_dmn = [('state','not in', ['cancelled', 'complete']),('direction','=','incoming')]
    ci_dmn = [('state','in', ['cancelled', 'complete']),('direction','=','outgoing'),('check_out','=',False)]
    cp_dmn = [('state','in', ['cancelled', 'complete']),('direction','=','incoming'),('check_out','=',False)]
    if orders:
        for dmn in (oi_dmn, op_dmn, ci_dmn, cp_dmn):
            dmn.append(('local_source_document','in',orders))
    open_invoices = OE.fnx_shipping.search_read(
            fields=['id', 'appointment_date', 'local_source_document', 'state'],
            domain=oi_dmn,
            )
    open_purchases = OE.fnx_shipping.search_read(
            fields=['id', 'local_source_document', 'state'],
            domain=op_dmn,
            )
    closed_invoices = OE.fnx_shipping.search_read(
            fields=['id', 'local_source_document', 'state'],
            domain=ci_dmn,
            )
    closed_purchases = OE.fnx_shipping.search_read(
            fields=['id', 'local_source_document', 'state'],
            domain=cp_dmn,
            )
    completed = {}
    cancelled = {}
    reopened = {}
    missing_invoices = []
    missing_purchases = []
    erp_documents = set()
    # order status
    for order in ProgressView(
            iterable=open_invoices,
            message='sorting $total invoices',
            view_type='bar',
        ):
        erp_documents.add(order.local_source_document)
        found = fis_orders.get_subset(order.local_source_document)
        for key, record in found:
            # will only be one record, if any
            status = record[F36.inv_flag].upper()
            if status == 'B':
                continue
            elif status == 'V':
                cancelled[order.id] = order.local_source_document
                logger.debug('%6s: status -> %r [cancelling]', order.local_source_document, status)
            else:
                logger.debug('%6s: status -> %r [no action]', order.local_source_document, status)
            break
        else:
            logger.debug('%6s: status -> %r [completing]', order.local_source_document, status)
            completed[order.id] = order.local_source_document
    for order in ProgressView(
            iterable=open_purchases,
            message='sorting $total purchase orders',
            view_type='bar',
        ):
        erp_documents.add(order.local_source_document)
        found = fis_purchases.get_subset(order.local_source_document)
        for key, record in found:
            reg_flag = record[F219.po_reg_flag].upper()
            confirmed = record[F219.confirmed_flag].upper()
            if reg_flag == 'V':
                logger.debug(
                        '%6s: reg_flag -> %r   confirmed -> %r [cancelling]',
                        order.local_source_document, reg_flag, confirmed,
                        )
                cancelled[order.id] = order.local_source_document
            elif confirmed == '3':
                continue
            else:
                logger.debug(
                        '%6s: reg_flag -> %r   confirmed -> %r [no action]',
                        order.local_source_document, reg_flag, confirmed,
                        )
            break
        else:
            logger.debug(
                    '%6s: reg_flag -> %r   confirmed -> %r [completing]',
                    order.local_source_document, reg_flag, confirmed,
                    )
            completed[order.id] = order.local_source_document
    if reopen:
        for order in ProgressView(
                iterable=closed_invoices,
                message='checking $total completed orders',
                view_type='bar',
            ):
            erp_documents.add(order.local_source_document)
            found = fis_orders.get_subset(order.local_source_document)
            for key, record in found:
                # will only be one record, if any
                status = record[F36.inv_flag].upper()
                # print('document %s: %r' % (order.local_source_document, status))
                if status in ('B', 'V'):
                    # already closed/cancelled, no need to change anything
                    break
                else:
                    reopened[order.id] = order.local_source_document
        for order in ProgressView(
                iterable=closed_purchases,
                message='checking $total completed purchase orders',
                view_type='bar',
            ):
            erp_documents.add(order.local_source_document)
            found = fis_purchases.get_subset(order.local_source_document)
            for key, record in found:
                reg_flag = record[F219.po_reg_flag].upper()
                confirmed = record[F219.confirmed_flag].upper()
                if reg_flag == 'V' or confirmed == '3':
                    # already closed/cancelled, no need to change anything
                    break
                else:
                    reopened[order.id] = order.local_source_document
    if cancelled:
        for ids in ProgressView(iterable=cancelled.keys(), message='cancelling $total orders', view_type='bar'):
            OE.fnx_shipping.write(ids, {'state': 'cancelled'})  #, context={'message_track': False})
    if completed:
        for ids in grouped(ProgressView(iterable=completed.keys(), message='updating state for $total orders', view_type='bar'), 100):
            OE.fnx_shipping.write(ids, {'state': 'complete'})  #, context={'message_track': False})
    if reopened:
        for ids in ProgressView(iterable=reopened.keys(), message='reopening $total orders', view_type='bar'):
            OE.fnx_shipping.write(ids, {'state': 'draft'}, context={'message_track': False})
            OE.fnx_shipping.write(ids, {'state': 'uncancel'})  #, context={'message_track': False})
    # dates
    changed_shipping = 0
    still_open_invoices = OE.fnx_shipping.search_read(
            fields=['id', 'appointment_date', 'local_source_document', 'state'],
            domain=oi_dmn,
            )
    for order in ProgressView(
            iterable=still_open_invoices,
            message='checking $total invoices for changed dates',
            view_type='bar',
        ):
        found = fis_orders.get_subset(order.local_source_document)
        for key, record in found:
            # will only be one record
            try:
                fis_ship_date = fix_date(record[F36.ship_date], format='ymd')
            except ValueError:
                # bad date skip
                logger.debug(
                        '%6s: ship-date -> %r [bad data, no action]',
                        order.local_source_document, record[F36.ship_date],
                        )
                continue
            erp_ship_date = date(order.appointment_date)
            if fis_ship_date is not None and fis_ship_date != erp_ship_date:
                fis_ship_date = fis_ship_date.strftime('%Y%m%d')
                changed_shipping += 1
                logger.debug(
                        '%6s: ship-date -> %r [updating]',
                        order.local_source_document, fis_ship_date,
                        )
                OE.fnx_shipping.write(
                        order.id,
                        {'appointment_date':fis_ship_date, 'appointment_time': 0},
                        )
            else:
                logger.debug(
                        '%6s: ship-date -> %r [no data, no action]',
                        order.local_source_document, record[F36.ship_date],
                        )
    still_open_purchases = OE.fnx_shipping.search_read(
            fields=['id', 'appointment_date', 'local_source_document', 'state'],
            domain=op_dmn,
            )
    for order in ProgressView(
            iterable=still_open_purchases,
            message='checking $total purchases for changed dates',
            view_type='bar',
        ):
        found = fis_purchases.get_subset(order.local_source_document)
        for key, record in found:
            # will only be one record
            try:
                fis_ship_date = fix_date(record[F219.ship_date], format='ymd')
            except ValueError:
                # bad date skip
                logger.debug(
                        '%6s: ship-date -> %r [bad data, no action]',
                        order.local_source_document, record[F36.ship_date],
                        )
                continue
            erp_ship_date = date(order.appointment_date)
            if fis_ship_date is not None and fis_ship_date != erp_ship_date:
                fis_ship_date = fis_ship_date.strftime('%Y%m%d')
                changed_shipping += 1
                logger.debug(
                        '%6s: ship-date -> %r [updating]',
                        order.local_source_document, fis_ship_date,
                        )
                OE.fnx_shipping.write(
                        order.id,
                        {'appointment_date':fis_ship_date, 'appointment_time': 0},
                        )
            else:
                logger.debug(
                        '%6s: ship-date -> %r [no data, no action]',
                        order.local_source_document, record[F36.ship_date],
                        )
    # missing orders
    if show_missing:
        for record in ProgressView(
                iterable=fis_orders,
                message='searching for missing invoices',
                view_type='bar',
            ):
            order_no = record[F36.order_no]
            if orders and order_no not in orders:
                continue
            elif order_no and order_no not in erp_documents:
                missing_invoices.append(order_no)
        for record in ProgressView(
                iterable=fis_purchases,
                message='searching for missing purchase orders',
                view_type='bar',
            ):
            order_no = record[F219.po_no]
            if orders and order_no not in orders:
                continue
            elif order_no and order_no not in erp_documents:
                missing_purchases.append(order_no)
        missing_invoices.sort()
        missing_purchases.sort()
    print('completed %d orders' % len(completed))
    print('cancelled %d orders' % len(cancelled))
    print('dates synced with FIS:', changed_shipping)
    if reopen:
        print('reopened %d orders' % len(reopened))
    if show_missing:
        echo()
        echo('missing invoices:', ', '.join(missing_invoices))
        echo()
        echo('missing purchase orders:', ', '.join(missing_purchases))


def update_order(values):
    # carrier is the shipping agent
    # partner is the vendor/customer
    # partner_source_document is the vendor/customer invoice number / purchase order
    # local_source_document is the purchase order / invoice number
    # local_contact is the falcon user
    #
    # appointment_date -> 20140107
    # carrier_xmlid --> 99
    # cartons --> 9
    # direction --> outgoing
    # local_contact --> 'sysadmin', 'rgiannini', 'ethan']
    # local_source_document --> 999999
    # pallets --> 3
    # partner_source_document --> PO TEST
    # partner_xmlid --> AWGRO
    # weight --> 139
    if not values.local_source_document:
        raise BadFormat('missing local source document')
    context = PropertyDict()
    local_contacts = values.pop('local_contact', None)
    print('local_contacts:', local_contacts)
    if local_contacts is not None:
        local_contacts = [lc for lc in set(local_contacts) if lc not in ('sysadmin', 'rgiannini')]
        records = OE.res_users.search_read(fields=['id', 'partner_id'], domain=[('login','in',local_contacts)])
        print('found:\n', '\n'.join(repr(r) for r in records))
        values.message_follower_ids = [lc['partner_id'][0] for lc in records]
    partner_xmlid = values.pop('partner_xmlid', None)
    if partner_xmlid is not None:
        records = OE.res_partner.search_read(
                fields=['id', 'module', 'xml_id'],
                domain=[('module','=',fis_module[values.direction]),('xml_id','=',partner_xmlid)],
                )
        if not records:
            raise MissingPartner('unable to find partner %r in OpenERP' % partner_xmlid)
        partner_id = records[0]['id']
        values.partner_id = context.default_partner_id =  partner_id
    carrier_xmlid = values.pop('carrier_xmlid', None)
    if carrier_xmlid not in (None, ):
        records = OE.res_partner.search_read(
                fields=['id'],
                domain=[('module','=',fis_module['carrier']),('xml_id','=',carrier_xmlid)],
                )
        if not records:
            raise MissingPartner('unable to find carrier %r in OpenERP' % carrier_xmlid)
        carrier_id = records[0]['id']
        values.carrier_id = carrier_id
    if 'cartons' in values:
        values.cartons = int(values.cartons) or False
    if 'pallets' in values:
        values.pallets = int(values.pallets) or False
    if 'weight' in values:
        values.weight = float(values.weight) or False
    direction = values.get('direction')
    if direction is None and values.cartons or values.pallets or values.weight:
        # only present on outgoing orders
        direction = 'outgoing'
    if direction == 'incoming':
        values.job_title = values.preposition = values.partner_source_document_type = 'purchasing'
    elif direction == 'outgoing':
        values.job_title = values.preposition = values.partner_source_document_type = 'sales'
    orders = OE.fnx_shipping.search_read(
            fields=['id'],
            domain=[('local_source_document','=',values.local_source_document)],
            )
    if len(orders) > 1:
        raise ValueError(
                'found more than one order matching %r: %r'
                % (values.local_source_document, [r.id for r in orders])
                )
    elif len(orders) == 1:
        order = orders[0]
    else:
        order = None
    print('order:', order)
    if not order:
        if not direction:
            raise BadFormat('cannot create new document %r without a direction' % values.local_source_document)
    login = values.pop('user', None)
    if login:
        records = OE.res_users.search_read(fields=['id'], domain=[('login','=',login)])
        values.login_id = records[0]['id']
    if not order:
        try:
            print('creating:\n', values)
            OE.fnx_shipping.create(dict(values), context=dict(context))
        except xmlrpclib.ProtocolError, exc:
            raise BadFormat('Order %s: %s' % (order, (exc)))
        except Exception, exc:
            print(exc, file=stderr)
            raise
    else:
        try:
            print('updating:', values.items())
            OE.fnx_shipping.write([order['id']], dict(values))
        except xmlrpclib.ProtocolError, exc:
            raise BadFormat('Order %s: %s' % (order, (exc)))
        except Exception, exc:
            print(exc, file=stderr)
            raise

def get_files(source=SOURCE):
    files = [source/f for f in source.listdir() if f != 'order_template']
    files.sort(key=lambda f: f.stat().st_mtime)
    return files

def connect_oe(hostname, database, user, password):
    OE.conn = conn = get_connection(hostname=hostname, database=database, login=user, password=password)
    OE.res_partner = conn.get_model('res.partner')
    OE.res_users = conn.get_model('res.users')
    OE.fnx_shipping = conn.get_model('fnx.sr.shipping')


class F36(str, Enum):
    """
    RDERH - OPEN ORDER HEADER MAINTENANCE & INQUIRY
    """
    company_id                   = 'An$(1,2)'      # Company Code
    order_no                     = 'An$(3,6)'      # Order No
    release_no                   = 'An$(9,2)'      # Release No
    type_0000                    = 'An$(11,4)'     # TYPE = '0000'
    inv_flag                     = 'Kn$(4,1)'      # Invoice Flag
    ship_date                    = 'Mn$(7,6)'      # Ship Date

class F219(str, Enum):
    """
    POHF - PURCHASE ORDER HEADER FILE
    """
    company_id          = 'An$(1,2)'      # COMPANY CODE
    po_no               = 'An$(3,5)'      # P/O NUMBER
    release_no          = 'An$(8,2)'      # RELEASE NUMBER
    supplier_no         = 'Bn$'           # SUPPLIER NUMBER
    supplier_name       = 'Cn$'           # SUPPLIER NAME
    addr_line_1         = 'Dn$'           # ADDR LINE 1
    addr_line_2         = 'En$'           # ADDR LINE 2
    addr_line_3         = 'Fn$'           # ADDR LINE 3
    order_placed_by_for = 'Gn$'           # ORDER PLACED BY/FOR
    order_issued_to     = 'Hn$'           # ORDER ISSUED TO
    terms               = 'In$'           # TERMS
    fob                 = 'Jn$'           # F.O.B.
    po_reg_flag         = 'Kn$(1,1)'      # P/O REG FLAG
    vouchered           = 'Kn$(2,1)'      # Vouchered (Y/N)
                                          # (open) Kn$(3,1)
    print_flag          = 'Kn$(4,1)'      # PRINT FLAG
                                          # (open) Kn$(5,1)
    ammended_p_o        = 'Kn$(6,1)'      # Ammended P/O?
    confirmed_flag      = 'Kn$(7,1)'      # CONFIRMED FLAG
                                          # (open) Kn$(8,1)
    po_recvd_complete   = 'Kn$(9,1)'      # P.O. RECVD COMPLETE?
    terms_id            = 'Kn$(10,1)'     # TERMS CODE
    taxable             = 'Kn$(11,1)'     # TAXABLE?
    carrier_id          = 'Kn$(12,2)'     # Carrier Code
    voucher_no          = 'Kn$(14,6)'     # Voucher Number
    warehouse           = 'Kn$(20,4)'     # WAREHOUSE (I/C)
    warehouse           = 'Kn$(24,4)'     # WAREHOUSE (DEL)
    fob_id              = 'Kn$(28,2)'     # FOB CODE
    po_type             = 'Kn$(30,2)'     # P/O Type
    used                = 'Kn$(32,1)'     # Used
    prod_order          = 'Kn$(33,1)'     # Production Order?
                                          # (open) Kn$(34,7)
    order_date          = 'On$(1,6)'      # ORDER DATE
    eta_date            = 'On$(7,6)'      # ETA DATE
    date_wanted         = 'Pn$(1,8)'      # DATE WANTED
    date_ammended       = 'Pn$(9,8)'      # Date Ammended
    carrier             = 'Qn$'           # CARRIER
    last_rec_date       = 'Rn$'           # LAST REC DATE
    disc_types          = 'Sn$(1,3)'      # Discount Types
    freight_type        = 'Sn$(4,1)'      # Freight Type
                                          # (open) An
    total_units         = 'Tn'            # TOTAL UNITS
    total_weight        = 'Un'            # TOTAL WEIGHT
    total_amt           = 'Vn'            # TOTAL AMOUNT
    no_of_lines         = 'Wn'            # Number of Lines
    operator_id         = 'Xn$'           # Operator Code
    disc_1_rate_amt     = 'Tt(1)'         # Disc 1 - Rate/Amt
    disc_2_rate_amt     = 'Tt(2)'         # Disc 2 - Rate/Amt
    disc_3_rate_amt     = 'Tt(3)'         # Disc 3 - Rate/Amt
    freight_rate_amt    = 'Tt(4)'         # Freight Rate/Amt
    no_of_pallets       = 'Tt(5)'         # Number of Pallets

DEFAULT_SERVER_DATE_FORMAT = "%Y-%m-%d"
DEFAULT_SERVER_TIME_FORMAT = "%H:%M:%S"
DEFAULT_SERVER_DATETIME_FORMAT = "%s %s" % (
    DEFAULT_SERVER_DATE_FORMAT,
    DEFAULT_SERVER_TIME_FORMAT)


Main()
